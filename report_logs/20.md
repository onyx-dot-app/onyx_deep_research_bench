Query ID: 20
============================================================

QUESTION:
研究下Anthropic最新发布的Streamable HTTP的工程中的具体实现方案

============================================================

RESEARCH TASKS (6 total):
  #1: 调研 Anthropic 最新“Streamable HTTP”发布内容中与工程实现相关的官方资料：重点找官方文档/公告/变更日志里对 streamable HTTP 的定义、与旧 streaming/SSE 的关系、以及是否提供参考实现或示例仓库链接；同时记录所有涉及服务端/代理配置/超时与缓冲的工程建议。
  #2: 调研 Anthropic 官方工程/示例中“服务端实现 Streamable HTTP”的具体做法：在 Node.js（Express/Fastify/原生 fetch/undici）、Python（ASGI/FastAPI/Starlette）、Go（net/http）、Java（Servlet/Netty）等常见栈中如何写 handler、如何逐步写出并 flush、如何处理 backpressure/取消/断连；如果官方只提供部分语言示例，也要总结其关键模式和可迁移点。
  #3: 调研 Anthropic 官方 SDK（尤其是 TypeScript/JavaScript 与 Python）对 Streamable HTTP 的客户端实现：如何发起请求、如何解析增量事件、事件/帧格式、错误与终止处理、取消与重试；重点查看 SDK 源码中的实现细节（解析器、异步迭代器/回调 API、资源释放）。
  #4: 请直接在 modelcontextprotocol/typescript-sdk 的最新主分支中定位并阅读 StreamableHTTPServerTransport/StreamableHTTPClientTransport 的源码与官方示例（路径可能已变更）。总结服务端如何处理 POST/GET/DELETE、SSE 写出与 flush、sessionId 生成与 Mcp-Session-Id header、resumability/Last-Event-ID/retry 的实现、以及并发隔离策略。
  #5: 请在 modelcontextprotocol/go-sdk 的 examples/http 示例与 mcp.NewStreamableHTTPHandler 相关源码中，梳理 Streamable HTTP 服务端 handler 的具体实现：路由匹配（单端点）、对 Accept/Content-Type 的分支、如何启动 SSE（GET 与 POST->SSE）、如何立即 flush headers、如何写出 event（event/message/data/id/retry）、断连检测与取消语义、以及 session 管理与 202/400/404/405 等状态码处理。
  #6: 请在 modelcontextprotocol/java-sdk 中查找 Streamable-HTTP transport 的具体实现代码（Servlet/WebFlux/WebMvc）与示例配置，补足文档中截断的部分：如何在 Servlet 容器里注册 endpoint、如何写出 text/event-stream 并 flush、session storage/resumability 的支持情况、Stateless Streamable-HTTP 子集的实现细节与限制，以及在多实例部署下的消息路由建议。

============================================================

ANSWER:
下面的“Streamable HTTP”并不是 Claude **Messages API 的 SSE 流式输出**（`stream: true` 那套）[[1]](https://docs.anthropic.com/en/api/messages-streaming)[[2]](https://platform.claude.com/docs/en/build-with-claude/streaming)，而是 Anthropic 推动的 **Model Context Protocol (MCP)** 在“远程传输层（remote transport）”里最新规范化的一套 **单端点 HTTP 传输**：**Streamable HTTP transport**。 [[5]](https://modelcontextprotocol.io/specification/2025-03-26/basic/transports)[[6]](https://modelcontextprotocol.io/specification/2025-11-25/basic/transports)[[9]](https://modelcontextprotocol.io/docs/learn/architecture)  
它被 Anthropic 用于（至少）两类工程落地：

1) **你自己实现远程 MCP Server**（对外暴露 `https://.../mcp`），让 Claude Desktop / Claude Code / 你自己的 MCP Client 连接；  
2) **通过 Claude API 的 MCP connector** 让 Anthropic 侧代你连接远程 MCP Server（`mcp_servers`），该 connector 同时支持 Streamable HTTP 与 SSE 两种 transport。 [[3]](https://docs.anthropic.com/en/docs/agents-and-tools/mcp-connector)[[4]](https://platform.claude.com/docs/en/agents-and-tools/mcp-connector)

下面按“协议→服务端实现→客户端实现→工程化部署/迁移→生产级设计”的顺序，把官方规范与各语言 SDK/示例里能确认的工程方案讲清楚，并指出当前资料缺口（哪些点需要你去读源码或踩坑验证）。

---

## 1) Streamable HTTP 的定位与“最新发布”变化（相对旧 HTTP+SSE）

### 1.1 替代旧的“HTTP+SSE 双端点”结构
MCP 旧版（2024-11-05）的 HTTP streaming 方案要求 **两个端点**：  
- 一个 SSE endpoint（客户端先连上，接收 server 消息）  
- 一个 POST endpoint（客户端发消息）  
并且服务端在 SSE 连接建立后要先发一个名为 `endpoint` 的 SSE event，把“POST endpoint 的 URI”告诉客户端。 [[7]](https://modelcontextprotocol.io/specification/2024-11-05/basic/transports)

**Streamable HTTP（2025-03-26 起、2025-11-25 延续）明确取代了旧 HTTP+SSE transport**： [[5]](https://modelcontextprotocol.io/specification/2025-03-26/basic/transports)[[6]](https://modelcontextprotocol.io/specification/2025-11-25/basic/transports)  
- 服务端只需要提供 **一个 MCP endpoint path**，同时支持 **POST + GET**（例如 `https://example.com/mcp`）[[5]](https://modelcontextprotocol.io/specification/2025-03-26/basic/transports)[[6]](https://modelcontextprotocol.io/specification/2025-11-25/basic/transports)  
- POST 用于 client→server 的 JSON-RPC 消息；GET 可选用于建立 server→client 的 SSE stream[[5]](https://modelcontextprotocol.io/specification/2025-03-26/basic/transports)[[6]](https://modelcontextprotocol.io/specification/2025-11-25/basic/transports)

这件事对工程实现的最大影响是：**反向代理、路由、鉴权、限流、观测都从“两个端点协商”简化为“一个端点统一治理”**，但你需要正确实现 **method 分发 + session 头 +（可选）SSE**。

### 1.2 “Streamable HTTP”并不意味着一定要 SSE：它允许纯 JSON 响应
规范强调：Streamable HTTP 仍然可以 **可选**使用 SSE 来“在一个 HTTP 响应里流式发送多条 server 消息”，从而支持通知（notifications）、server→client request、以及更丰富的交互；但也允许只用 `application/json` 返回单次响应，做“基础/简化”的 MCP server。 [[5]](https://modelcontextprotocol.io/specification/2025-03-26/basic/transports)[[6]](https://modelcontextprotocol.io/specification/2025-11-25/basic/transports)

在各语言 SDK 里，这通常对应两种服务端形态：
- **Feature-rich / Stateful / SSE-enabled**：更接近完整 MCP 能力（通知、server request、恢复等）  
- **Stateless / JSON-only 子集**：更像传统 REST：每次 POST 进来、算完、回 JSON；不维持长连接/会话（水平扩展更容易），但能力会受限（例如难以向客户端推通知/请求）。在 Java SDK 的 stateless 形态里这种限制被明确提及。 [[12]](https://modelcontextprotocol.io/sdk/java/mcp-server)

---

## 2) 协议与报文语义（你写 handler 时必须满足的硬约束）

以下以 MCP 规范为准（2025-11-25 / 2025-03-26 两版都要注意差异点）。

### 2.1 单端点：同一路径必须支持 POST 与 GET
服务端 **MUST** 提供一个 MCP endpoint path，同时支持 POST 与 GET。 [[5]](https://modelcontextprotocol.io/specification/2025-03-26/basic/transports)[[6]](https://modelcontextprotocol.io/specification/2025-11-25/basic/transports)

### 2.2 POST（发送 JSON-RPC 到服务端）
- **每条 JSON-RPC message 必须是一次新的 HTTP POST**。 [[5]](https://modelcontextprotocol.io/specification/2025-03-26/basic/transports)[[6]](https://modelcontextprotocol.io/specification/2025-11-25/basic/transports)  
- 客户端 POST 必须带 `Accept`，且同时包含：  
  `application/json` 与 `text/event-stream`。 [[5]](https://modelcontextprotocol.io/specification/2025-03-26/basic/transports)[[6]](https://modelcontextprotocol.io/specification/2025-11-25/basic/transports)（Go SDK 服务端会严格校验 Accept：非 GET 要求两者都出现）[[53]](https://raw.githubusercontent.com/modelcontextprotocol/go-sdk/v1.2.0/mcp/streamable.go)
- 服务端对 POST 的响应分三类（非常关键）：

**A) 输入是 response 或 notification**  
- 服务端接受：返回 **202 Accepted** 且 **无 body**。 [[5]](https://modelcontextprotocol.io/specification/2025-03-26/basic/transports)[[6]](https://modelcontextprotocol.io/specification/2025-11-25/basic/transports)  
- 不接受：返回 HTTP 错误码（如 400），body 可选 JSON-RPC error（无 id）。[[5]](https://modelcontextprotocol.io/specification/2025-03-26/basic/transports)[[6]](https://modelcontextprotocol.io/specification/2025-11-25/basic/transports)  
> 这是很多互操作问题/超时问题的根源：有些实现错误地对 notification 返回 200 + JSON，客户端/代理可能会等待或误判。

**B) 输入包含 request（JSON-RPC request）**  
服务端必须二选一：  
- 返回 `Content-Type: text/event-stream`（开启 SSE stream，在这个 stream 里可以先发通知/请求，最终必须发 response）[[5]](https://modelcontextprotocol.io/specification/2025-03-26/basic/transports)[[6]](https://modelcontextprotocol.io/specification/2025-11-25/basic/transports)  
- 或返回 `Content-Type: application/json`（单次 JSON 响应）[[5]](https://modelcontextprotocol.io/specification/2025-03-26/basic/transports)[[6]](https://modelcontextprotocol.io/specification/2025-11-25/basic/transports)  
并且客户端必须同时支持两种响应形态。 [[5]](https://modelcontextprotocol.io/specification/2025-03-26/basic/transports)[[6]](https://modelcontextprotocol.io/specification/2025-11-25/basic/transports)

**C) POST body 是否允许 batch：两版规范有差异**
- 2025-03-26：允许单条 message 或 batch（数组）[[5]](https://modelcontextprotocol.io/specification/2025-03-26/basic/transports)  
- 2025-11-25：收紧为 **POST body 必须是单条 request/notification/response**（不再允许 batch）[[6]](https://modelcontextprotocol.io/specification/2025-11-25/basic/transports)  
> 工程建议：服务端实现最好能兼容旧 client（仍发 batch）与新规范（单条），至少在迁移期做“兼容解析 + 明确告警”。

### 2.3 GET（可选：建立 SSE stream 接收服务端消息）
- 客户端 MAY 对 MCP endpoint 发 GET 来打开 SSE stream。 [[5]](https://modelcontextprotocol.io/specification/2025-03-26/basic/transports)[[6]](https://modelcontextprotocol.io/specification/2025-11-25/basic/transports)  
- GET 必须带 `Accept: text/event-stream`。 [[5]](https://modelcontextprotocol.io/specification/2025-03-26/basic/transports)[[6]](https://modelcontextprotocol.io/specification/2025-11-25/basic/transports)（Go SDK 服务端会严格校验，否则直接 400）[[53]](https://raw.githubusercontent.com/modelcontextprotocol/go-sdk/v1.2.0/mcp/streamable.go)  
- 服务端必须：  
  - 要么返回 `Content-Type: text/event-stream`  
  - 要么返回 **405 Method Not Allowed** 表示不提供 SSE stream。 [[5]](https://modelcontextprotocol.io/specification/2025-03-26/basic/transports)[[6]](https://modelcontextprotocol.io/specification/2025-11-25/basic/transports)  
> TypeScript 示例里，很多“纯 JSON/无通知”的服务器会选择 GET=405。 [[51]](https://raw.githubusercontent.com/modelcontextprotocol/typescript-sdk/refs/heads/main/examples/server/src/simpleStatelessStreamableHttp.ts)[[48]](https://raw.githubusercontent.com/modelcontextprotocol/typescript-sdk/refs/heads/main/examples/server/src/jsonResponseStreamableHttp.ts)

### 2.4 Session：`Mcp-Session-Id` / `MCP-Session-Id`
规范允许（且很多实现会用）有状态 session：
- 服务端 MAY 在 initialization 的 HTTP response header 返回 session id（规范文本里出现过 `Mcp-Session-Id` / `MCP-Session-Id` 两种大小写写法，工程上要做大小写不敏感处理）。[[5]](https://modelcontextprotocol.io/specification/2025-03-26/basic/transports)[[6]](https://modelcontextprotocol.io/specification/2025-11-25/basic/transports)
- 一旦服务端发了 session id：客户端后续所有请求都 **必须**带 session id header。 [[5]](https://modelcontextprotocol.io/specification/2025-03-26/basic/transports)[[6]](https://modelcontextprotocol.io/specification/2025-11-25/basic/transports)
- 服务端若要求 session：缺失 session id 的非初始化请求应返回 **400**。 [[5]](https://modelcontextprotocol.io/specification/2025-03-26/basic/transports)[[6]](https://modelcontextprotocol.io/specification/2025-11-25/basic/transports)
- 服务端终止 session 后：对该 session id 的请求必须返回 **404**；客户端收到 404 必须重新初始化新 session。 [[5]](https://modelcontextprotocol.io/specification/2025-03-26/basic/transports)[[6]](https://modelcontextprotocol.io/specification/2025-11-25/basic/transports)
- 客户端不需要 session 时 SHOULD 发 **HTTP DELETE**（带 session id）终止；服务端 MAY 用 405 表示不支持显式终止。 [[5]](https://modelcontextprotocol.io/specification/2025-03-26/basic/transports)[[6]](https://modelcontextprotocol.io/specification/2025-11-25/basic/transports)

Go SDK 的 StreamableHTTPHandler 就内建了：session map、404 session not found、DELETE=204、以及可选 SessionTimeout 自动关闭等行为。 [[53]](https://raw.githubusercontent.com/modelcontextprotocol/go-sdk/v1.2.0/mcp/streamable.go)

### 2.5 可恢复（resumability）：`id` / `Last-Event-ID`
- 服务端可在 SSE event 上附带 `id`（event id），客户端断线后可用 GET + `Last-Event-ID` 请求恢复。 [[5]](https://modelcontextprotocol.io/specification/2025-03-26/basic/transports)[[6]](https://modelcontextprotocol.io/specification/2025-11-25/basic/transports)
- 关键约束：**每个 JSON-RPC message 只能投递到一个 stream**，恢复时也不能“跨 stream 重放”。[[5]](https://modelcontextprotocol.io/specification/2025-03-26/basic/transports)[[6]](https://modelcontextprotocol.io/specification/2025-11-25/basic/transports)

2025-11-25 规范还增加了更工程化的“长连接治理”建议（下面 2.6）。[[6]](https://modelcontextprotocol.io/specification/2025-11-25/basic/transports)

### 2.6 2025-11-25 对“避免长连接 + 断线重连节流”的增强建议（非常工程化）
如果服务端选择用 SSE stream：
- **SHOULD 立刻发送一个带 event ID 且 data 为空的 SSE event**（priming），让 client 后续能用 `Last-Event-ID` 恢复。 [[6]](https://modelcontextprotocol.io/specification/2025-11-25/basic/transports)
- 服务端 **MAY 随时关闭连接**（不终止 SSE stream），让客户端“轮询式”重连（polling），以避免维持长连接。 [[6]](https://modelcontextprotocol.io/specification/2025-11-25/basic/transports)
- 服务端若主动断开但不终止 stream：  
  **SHOULD** 发送 SSE 标准 `retry:` 字段，再关闭；客户端 **MUST** 尊重 retry，按指定毫秒数等待再重连。 [[6]](https://modelcontextprotocol.io/specification/2025-11-25/basic/transports)

> 这几条对生产部署很关键：它给了你一个“兼容代理超时/连接配额”的官方推荐策略：**SSE 不必永远长连**，可以服务端主动断开 + 客户端按 retry backoff 重连。

### 2.7 安全警告（官方明确写进规范的部署要求）
- 服务端 **MUST 校验 Origin header**，防 DNS rebinding。 [[5]](https://modelcontextprotocol.io/specification/2025-03-26/basic/transports)[[6]](https://modelcontextprotocol.io/specification/2025-11-25/basic/transports)
- 本地运行的 server **SHOULD** 只绑定 `127.0.0.1`，不要绑定 `0.0.0.0`。 [[5]](https://modelcontextprotocol.io/specification/2025-03-26/basic/transports)[[6]](https://modelcontextprotocol.io/specification/2025-11-25/basic/transports)
- 服务端 **SHOULD** 对所有连接做正确认证。 [[5]](https://modelcontextprotocol.io/specification/2025-03-26/basic/transports)[[6]](https://modelcontextprotocol.io/specification/2025-11-25/basic/transports)
- 2025-11-25 还明确：若 Origin 存在且无效，必须 403。 [[6]](https://modelcontextprotocol.io/specification/2025-11-25/basic/transports)

---

## 3) Anthropic/MCP 官方工程里的服务端实现方案（按语言栈）

### 3.1 Node.js / TypeScript：`NodeStreamableHTTPServerTransport` + Express 路由

在 MCP TypeScript SDK 的官方示例（examples/server）中，典型落地方式是：

- 用 Express 建一个 `/mcp` 路由
- 每次请求把 `req`, `res`, `req.body` 交给 `transport.handleRequest(...)`
- 按需做 stateful（session）或 stateless（无 session）

#### 3.1.1 Stateless（每请求独立、GET/DELETE=405）
官方示例 `simpleStatelessStreamableHttp.ts` 的关键模式： [[51]](https://raw.githubusercontent.com/modelcontextprotocol/typescript-sdk/refs/heads/main/examples/server/src/simpleStatelessStreamableHttp.ts)
- `POST /mcp`：每次新建 `McpServer` + `NodeStreamableHTTPServerTransport({ sessionIdGenerator: undefined })`  
  然后 `await server.connect(transport)`，再 `await transport.handleRequest(req, res, req.body)`。 [[51]](https://raw.githubusercontent.com/modelcontextprotocol/typescript-sdk/refs/heads/main/examples/server/src/simpleStatelessStreamableHttp.ts)
- 监听 `res.on('close')`，在连接断开时 `transport.close()` 与 `server.close()`，避免资源泄露。 [[51]](https://raw.githubusercontent.com/modelcontextprotocol/typescript-sdk/refs/heads/main/examples/server/src/simpleStatelessStreamableHttp.ts)
- `GET /mcp`：直接 405 + JSON-RPC error（不提供 SSE stream）。[[51]](https://raw.githubusercontent.com/modelcontextprotocol/typescript-sdk/refs/heads/main/examples/server/src/simpleStatelessStreamableHttp.ts)
- `DELETE /mcp`：直接 405（不允许客户端终止 session）。[[51]](https://raw.githubusercontent.com/modelcontextprotocol/typescript-sdk/refs/heads/main/examples/server/src/simpleStatelessStreamableHttp.ts)

这种模式的工程含义：
- 优点：极易水平扩展（无粘滞会话）、天然隔离并发（不会出现“跨用户串 transport”）
- 代价：基本放弃 server→client 通知/请求与 resumability（因为没有跨请求状态）

#### 3.1.2 Stateful + JSON-only（session map 复用 transport，但仍不提供 GET SSE）
官方示例 `jsonResponseStreamableHttp.ts` 展示了“有 session，但强制 JSON 响应，不开 SSE”： [[48]](https://raw.githubusercontent.com/modelcontextprotocol/typescript-sdk/refs/heads/main/examples/server/src/jsonResponseStreamableHttp.ts)
- 服务端维护 `transports[sessionId] = transport` 的内存映射。 [[48]](https://raw.githubusercontent.com/modelcontextprotocol/typescript-sdk/refs/heads/main/examples/server/src/jsonResponseStreamableHttp.ts)
- 初始化请求（无 session id 且 body 是 InitializeRequest）时：
  - 创建 `NodeStreamableHTTPServerTransport({ sessionIdGenerator: () => randomUUID(), enableJsonResponse: true, onsessioninitialized })`。 [[48]](https://raw.githubusercontent.com/modelcontextprotocol/typescript-sdk/refs/heads/main/examples/server/src/jsonResponseStreamableHttp.ts)
  - 在 `onsessioninitialized` 回调里把 transport 放入 map，避免“初始化还没存进去就来下一请求”的竞态。 [[48]](https://raw.githubusercontent.com/modelcontextprotocol/typescript-sdk/refs/heads/main/examples/server/src/jsonResponseStreamableHttp.ts)
- 后续请求：按 `req.headers['mcp-session-id']` 找 transport，直接 `transport.handleRequest(...)`。 [[48]](https://raw.githubusercontent.com/modelcontextprotocol/typescript-sdk/refs/heads/main/examples/server/src/jsonResponseStreamableHttp.ts)
- session id 缺失或无效：返回 400。 [[48]](https://raw.githubusercontent.com/modelcontextprotocol/typescript-sdk/refs/heads/main/examples/server/src/jsonResponseStreamableHttp.ts)
- GET：405（不提供 SSE）。[[48]](https://raw.githubusercontent.com/modelcontextprotocol/typescript-sdk/refs/heads/main/examples/server/src/jsonResponseStreamableHttp.ts)

工程含义：
- 这是“介于 REST 与完整 MCP”之间的折中：有 session（所以可以保留某些上下文/状态），但不做 SSE 与通知。
- 并发与隔离风险：同一 session 的并发请求共享同一个 transport 对象，**transport 内部是否做串行化/并发安全**需要读 transport 源码才能完全确认（当前资料对 transport 内部实现存在缺口）。

#### 3.1.3 Resumability 的事件存储样例：`InMemoryEventStore`
MCP TS SDK examples 里给了 `InMemoryEventStore`（用于示例/测试）实现了 EventStore 的核心思想： [[49]](https://raw.githubusercontent.com/modelcontextprotocol/typescript-sdk/refs/heads/main/examples/server/src/inMemoryEventStore.ts)
- 每个事件存 `eventId -> { streamId, message }`。 [[49]](https://raw.githubusercontent.com/modelcontextprotocol/typescript-sdk/refs/heads/main/examples/server/src/inMemoryEventStore.ts)
- `eventId` 编码了 `streamId`（`<streamId>_<Date.now()>_<random>`），回放时从 `lastEventId` 解析 streamId，仅回放同一 stream 的事件，符合“不能跨 stream 重放”的规范约束。 [[49]](https://raw.githubusercontent.com/modelcontextprotocol/typescript-sdk/refs/heads/main/examples/server/src/inMemoryEventStore.ts)[[5]](https://modelcontextprotocol.io/specification/2025-03-26/basic/transports)
- 明确标注：这是 in-memory 示例，生产需要持久化存储。 [[49]](https://raw.githubusercontent.com/modelcontextprotocol/typescript-sdk/refs/heads/main/examples/server/src/inMemoryEventStore.ts)

> 你在生产要做 resumability，通常需要：  
> 1) 把 event 写入持久存储（至少按 session+stream 分区）  
> 2) 让负载均衡层把带 `Last-Event-ID` 的恢复 GET 路由到能读到同一份 event store 的实例（要么共享存储，要么粘滞路由）

#### 3.1.4 Node/TS 常见坑：多客户端串流（transport 不能做全局单例）
TypeScript SDK 的一个 issue 报告过严重问题：用户 A 的 notification 被发送给用户 B，怀疑是 connect() 覆盖了全局 transport 变量导致并发串线，建议按 clientId/会话隔离 transport 存储。 [[18]](https://github.com/modelcontextprotocol/typescript-sdk/issues/343)  
这类问题在你“自己写 server + 自己管理 transport/连接池”时尤其要警惕：**notification 的输出通道必须跟 session/stream 绑定**，不能是进程级全局单通道（否则必串）。

> 备注：目前我们拿到的材料里 **没有成功打开 TS SDK transport 的核心实现源码**（路径变更/抓取失败），因此 TS transport 内部如何做 flush、如何发 `retry:`、如何处理 `Last-Event-ID`，无法逐行复述；只能基于规范与示例来总结其“接入方式与设计意图”。[[45]](https://raw.githubusercontent.com/modelcontextprotocol/typescript-sdk/refs/heads/main/docs/server.md)[[46]](https://raw.githubusercontent.com/modelcontextprotocol/typescript-sdk/refs/heads/main/examples/server/src/simpleStreamableHttp.ts)[[47]](https://raw.githubusercontent.com/modelcontextprotocol/typescript-sdk/refs/heads/main/examples/client/src/simpleStreamableHttp.ts)

---

### 3.2 Go：`mcp.NewStreamableHTTPHandler`（net/http 一体化 handler，工程细节最完整）

Go SDK 这边能直接看到服务端 handler 的大量实现细节，是目前资料里最“工程可复用”的参考。

#### 3.2.1 示例怎么接：一个 handler 覆盖 GET/POST/DELETE
`examples/http` 的 server 用法： [[52]](https://raw.githubusercontent.com/modelcontextprotocol/go-sdk/v1.2.0/examples/http/main.go)
- `server := mcp.NewServer(...)` 注册 tools
- `handler := mcp.NewStreamableHTTPHandler(func(req *http.Request) *mcp.Server { return server }, nil)`
- `http.ListenAndServe(url, handler)`

这就是典型“单端点”落地：所有 method 都进同一个 handler，让 handler 内部按 method 与 session 头做分发。 [[52]](https://raw.githubusercontent.com/modelcontextprotocol/go-sdk/v1.2.0/examples/http/main.go)[[53]](https://raw.githubusercontent.com/modelcontextprotocol/go-sdk/v1.2.0/mcp/streamable.go)

#### 3.2.2 Accept 严格校验（避免客户端不兼容）
`StreamableHTTPHandler.ServeHTTP` 会解析可能存在的多个 `Accept` 头并拆分 token： [[53]](https://raw.githubusercontent.com/modelcontextprotocol/go-sdk/v1.2.0/mcp/streamable.go)
- GET：必须 Accept 包含 `text/event-stream`，否则 400。 [[53]](https://raw.githubusercontent.com/modelcontextprotocol/go-sdk/v1.2.0/mcp/streamable.go)
- 非 GET 且非 DELETE（主要是 POST）：必须同时包含 `application/json` 与 `text/event-stream`，否则 400。 [[53]](https://raw.githubusercontent.com/modelcontextprotocol/go-sdk/v1.2.0/mcp/streamable.go)

这点对互操作性很重要：如果你有客户端/代理会改写 Accept，可能直接导致 400。

#### 3.2.3 Session 管理、404/403/DELETE=204、以及会话劫持防护
Go handler 维护 `sessions map[sessionID]*sessionInfo`： [[53]](https://raw.githubusercontent.com/modelcontextprotocol/go-sdk/v1.2.0/mcp/streamable.go)
- 请求带 `Mcp-Session-Id`：
  - 找不到 session 且非 Stateless：404 `"session not found"`。 [[53]](https://raw.githubusercontent.com/modelcontextprotocol/go-sdk/v1.2.0/mcp/streamable.go)
  - 找到 session 且 session 绑定了 userID，则从 context 的 TokenInfo 取 UserID 比较，不一致返回 403，防 session hijacking。 [[53]](https://raw.githubusercontent.com/modelcontextprotocol/go-sdk/v1.2.0/mcp/streamable.go)
- DELETE：
  - 缺 session header：400
  - 有 session：关闭 session（幂等），最终返回 204 No Content。 [[53]](https://raw.githubusercontent.com/modelcontextprotocol/go-sdk/v1.2.0/mcp/streamable.go)

这能直接映射到规范的 404/DELETE 语义。 [[5]](https://modelcontextprotocol.io/specification/2025-03-26/basic/transports)[[6]](https://modelcontextprotocol.io/specification/2025-11-25/basic/transports)[[53]](https://raw.githubusercontent.com/modelcontextprotocol/go-sdk/v1.2.0/mcp/streamable.go)

#### 3.2.4 支持 Stateless / JSONResponse / EventStore / SessionTimeout 等工程开关
`StreamableHTTPOptions` 里可见几个关键工程选项： [[53]](https://raw.githubusercontent.com/modelcontextprotocol/go-sdk/v1.2.0/mcp/streamable.go)
- `Stateless`：不校验 session id；会创建“临时 session”，并通过偷看 request body 来判断是否包含 initialize/initialized，如果没有则补默认初始化状态，保证后续请求不会被 session 拒绝。 [[53]](https://raw.githubusercontent.com/modelcontextprotocol/go-sdk/v1.2.0/mcp/streamable.go)  
  （同时注释说明：stateless 下 server→client request 会被拒绝，通知在某些上下文可能仍可到达。）[[53]](https://raw.githubusercontent.com/modelcontextprotocol/go-sdk/v1.2.0/mcp/streamable.go)
- `JSONResponse`：让 streamable 响应使用 `application/json` 而不是 SSE（对应规范里“JSON-only response mode”概念）。[[53]](https://raw.githubusercontent.com/modelcontextprotocol/go-sdk/v1.2.0/mcp/streamable.go)
- `EventStore`：用于 stream resumption（断线恢复）。[[53]](https://raw.githubusercontent.com/modelcontextprotocol/go-sdk/v1.2.0/mcp/streamable.go)
- `SessionTimeout`：空闲超时自动 close session；并且 handler 会在 POST 期间暂停 idle timer、POST 结束后再恢复计时，避免长 POST 被误杀。 [[53]](https://raw.githubusercontent.com/modelcontextprotocol/go-sdk/v1.2.0/mcp/streamable.go)

这一套选项在生产非常实用：你可以根据部署环境（LB 超时、连接数限制、水平扩展需求）决定是否启用 session、是否启用 SSE、是否启用恢复。

#### 3.2.5 “必须 flush headers”的真实线上坑（SSE GET 挂起）
Go SDK 曾出现过一个实际 bug：GET（用于建立 SSE stream）如果长时间没有任何 event 输出，服务端虽然设置了 `Content-Type: text/event-stream`，但因为没有 write，headers 不会发出，客户端会一直阻塞等待响应头。 [[15]](https://github.com/modelcontextprotocol/go-sdk/issues/410)  
维护者确认：显式 Flush 可以修复，并合入修复提交 “flush headers immediately for the hanging GET”。[[15]](https://github.com/modelcontextprotocol/go-sdk/issues/410)

工程结论（跨语言通用）：
- **SSE 连接建立后，即使暂时没有业务事件，也应尽快把 headers 刷出去**  
- 最稳的方式是：  
  1) 写一个“priming event”（2025-11-25 规范也推荐）[[6]](https://modelcontextprotocol.io/specification/2025-11-25/basic/transports) 或注释行；  
  2) 立刻 flush（Go 是 `http.Flusher`，Java Servlet 是 `flushBuffer()`，Node 可能是 `res.flushHeaders()` / `res.flush()` 取决于框架与压缩中间件）。

---

### 3.3 Python：FastMCP / FastAPI 挂载（封装式落地 + 路径坑）

资料里最明确的 Python 工程落地来自 MCP Python SDK/示例的实践总结：

#### 3.3.1 FastMCP 与 FastAPI 集成方式
可用模式（示例转述）：[[21]](https://heeki.medium.com/building-an-mcp-server-as-an-api-developer-cfc162d06a83)
- `mcp = FastMCP("strava", stateless_http=True)`  
- `app = FastAPI(..., lifespan=lambda app: mcp.session_manager.run())`
- `app.mount("/strava", mcp.streamable_http_app())`

以及直接运行：`mcp.run(transport='streamable-http')`，并通过 host/port 参数配置 uvicorn。 [[21]](https://heeki.medium.com/building-an-mcp-server-as-an-api-developer-cfc162d06a83)

#### 3.3.2 默认路径：Streamable HTTP 默认挂到 `/mcp`
该实践材料强调：默认 SSE server 挂到 `/sse`，**Streamable HTTP 默认挂到 `/mcp`**。 [[21]](https://heeki.medium.com/building-an-mcp-server-as-an-api-developer-cfc162d06a83)  
因此如果你把 MCP app mount 到 `/strava`，真正 endpoint 变成 `/strava/mcp`（而不是 `/strava`）。[[21]](https://heeki.medium.com/building-an-mcp-server-as-an-api-developer-cfc162d06a83)

#### 3.3.3 FastAPI 307/尾斜杠重定向坑
实践中遇到过：请求 `/strava/mcp` 被 307 redirect 到 `/strava/mcp/`，然后才 200/202。 [[21]](https://heeki.medium.com/building-an-mcp-server-as-an-api-developer-cfc162d06a83)  
工程建议：  
- MCP endpoint 尽量固定不重定向（重定向可能导致某些 MCP 客户端/探测逻辑失败或超时）  
- 反向代理也要避免对 `/mcp` 做强制 trailing slash rewrite

---

### 3.4 Java：Servlet/WebFlux/WebMvc 的“可用能力”与“当前痛点”都很清晰（但源码级 flush 细节缺失）

Java 生态的材料更多来自文档 + issues，能确认“提供了什么”和“踩坑点在哪”，但对于“怎么 flush 写 SSE”没有拿到直接源码片段（资料缺口）。

#### 3.4.1 Java SDK 提供多种 transport provider
官方文档确认：Java MCP Server 提供 STDIO、Streamable-HTTP、SSE 的 server transport，并可选 Spring WebFlux/WebMVC 的 transport 依赖。 [[12]](https://modelcontextprotocol.io/sdk/java/mcp-server)[[24]](https://github.com/modelcontextprotocol/java-sdk)[[57]](https://modelcontextprotocol.io/sdk/java/mcp-overview)  
Spring AI 文档也列出了 server/client 的 starters，并支持通过配置切换 SSE / STREAMABLE / STATELESS。 [[58]](https://docs.spring.io/spring-ai/reference/api/mcp/mcp-overview.html)

#### 3.4.2 WebFlux 端：RouterFunction 同时注册 GET/POST/DELETE
从 WebFlux provider 的 issue 可直接看到：它内部用 RouterFunction 路由，同一个 endpoint 同时注册 `.GET(handleGet) .POST(handlePost) .DELETE(handleDelete)`。 [[65]](https://github.com/modelcontextprotocol/java-sdk/issues/621)

并且在 Spring 配置里常见 builder 参数包括：`messageEndpoint`、`keepAliveInterval`、`disallowDelete` 等。 [[65]](https://github.com/modelcontextprotocol/java-sdk/issues/621)

#### 3.4.3 多实例/高可用的核心问题：session 默认在内存 Map
有 issue 明确指出 servlet streamable server 当前把 sessions 放在进程内 `ConcurrentHashMap`，这会导致多副本部署必须依赖严格粘滞，否则后续携带 sessionId 的请求被路由到另一台就失败。 [[66]](https://github.com/modelcontextprotocol/java-sdk/issues/499)[[68]](https://github.com/modelcontextprotocol/java-sdk/issues/274)[[71]](https://github.com/modelcontextprotocol/java-sdk/issues/332)  
维护者/贡献者在相关讨论里给出的方向性建议包括： [[71]](https://github.com/modelcontextprotocol/java-sdk/issues/332)
- **优先用 Stateless Server Transport** 来水平扩展、避免 session 粘滞；[[71]](https://github.com/modelcontextprotocol/java-sdk/issues/332)
- 若必须 stateful：考虑 header-based 实例选择、或事件总线/Redis 广播把消息路由回持有 session 的实例。 [[71]](https://github.com/modelcontextprotocol/java-sdk/issues/332)

并且有人指出 stateless 的已知限制：不支持 message requests 到 MCP client（elicitation/sampling/ping 等）。[[68]](https://github.com/modelcontextprotocol/java-sdk/issues/274)

#### 3.4.4 互操作与状态码：GET 不支持 SSE 时必须 405；notification 接受必须 202
Java 的互操作 issue 里直接引用规范强调：GET 必须返回 `text/event-stream` 或 405。 [[60]](https://github.com/modelcontextprotocol/java-sdk/issues/582)  
另一些讨论反复强调：notification/response 被接受时必须返回 202 且无 body，否则客户端会等待/超时或报错。 [[61]](https://github.com/modelcontextprotocol/java-sdk/issues/396)[[60]](https://github.com/modelcontextprotocol/java-sdk/issues/582)

> 这也是你实现 server 时非常常见的坑：  
> - 你“觉得”notification 不需要回包就直接断连接，或者回 200 + JSON  
> - 但客户端/SDK 期待的是明确的 202/空 body；否则会把连接当成“没成功/没结束”而 hang。

#### 3.4.5 Servlet 容器注册的现实问题：构造器 private、WAR 部署不直观
多个 issue 反映：某些 Servlet provider 类构造器是 private，导致容器无法通过 `@WebServlet` 直接实例化；也不易通过继承扩展来做安全增强或集成到已有 Tomcat 应用。 [[62]](https://github.com/modelcontextprotocol/java-sdk/issues/763)[[63]](https://github.com/modelcontextprotocol/java-sdk/issues/497)[[64]](https://github.com/modelcontextprotocol/java-sdk/issues/627)  
有人建议用 Filter/委派方式复用 SDK provider，并引用 Jenkins 插件作为参考。 [[63]](https://github.com/modelcontextprotocol/java-sdk/issues/497)  
> 结论：Java Servlet 场景下“最标准的嵌入姿势”在目前材料里没有官方一锤定音的示例代码，这是你做工程落地前要特别预留时间验证的点。

---

## 4) 客户端实现：哪些是 Anthropic SDK 做的，哪些是 MCP SDK 做的？

这里要把两条“流式”链路分清：

### 4.1 Anthropic 官方 SDK（@anthropic-ai/sdk、anthropic-python）实现的是 **Claude Messages API 的 SSE streaming**
Anthropic 的 TS 与 Python SDK 都内置了 SSE 解码器与流式消费 API，用来消费 Messages API 的 streaming events（`message_start/delta/stop`、`content_block_*`、`ping`、`error` 等）。[[27]](https://github.com/anthropics/anthropic-sdk-python/blob/main/src/anthropic/_streaming.py)[[28]](https://github.com/anthropics/anthropic-sdk-typescript/blob/main/src/core/streaming.ts)[[1]](https://docs.anthropic.com/en/api/messages-streaming)[[2]](https://platform.claude.com/docs/en/build-with-claude/streaming)

- Python SDK：`Stream/AsyncStream` 在 finally 强制 close response，确保“即便用户不读完也释放连接”。[[27]](https://github.com/anthropics/anthropic-sdk-python/blob/main/src/anthropic/_streaming.py)  
- TS SDK：`Stream.fromSSEResponse` 用 `AbortController` 管理取消；用户 break 时会 `controller.abort()`；遇到 abort error 会静默退出不抛。 [[28]](https://github.com/anthropics/anthropic-sdk-typescript/blob/main/src/core/streaming.ts)  
- TS SDK MessageStream：把外部 signal 绑定到内部 controller，并在底层流 aborted 时抛 `APIUserAbortError`。 [[29]](https://github.com/anthropics/anthropic-sdk-typescript/blob/main/src/lib/MessageStream.ts)

这些都与 **MCP Streamable HTTP**不是同一件事，但它们提供了 SSE 工程实现的参考（解析、取消、资源释放、未知事件健壮性等）[[1]](https://docs.anthropic.com/en/api/messages-streaming)[[2]](https://platform.claude.com/docs/en/build-with-claude/streaming)[[27]](https://github.com/anthropics/anthropic-sdk-python/blob/main/src/anthropic/_streaming.py)[[28]](https://github.com/anthropics/anthropic-sdk-typescript/blob/main/src/core/streaming.ts)。

### 4.2 MCP 的 Streamable HTTP client transport：主要由 MCP SDK 提供（Python 有完整源码）
**MCP Python SDK 的 `StreamableHTTPTransport`** 是目前材料中“客户端实现细节最完整”的一份：

#### 4.2.1 请求头注入（Accept、Session、Protocol Version）
它会准备 headers： [[39]](https://github.com/modelcontextprotocol/python-sdk/blob/main/src/mcp/client/streamable_http.py)
- `accept: "application/json, text/event-stream"`
- `content-type: "application/json"`
- 若已有 session：加 `mcp-session-id`
- 若已协商 protocol version：加 `mcp-protocol-version`  
并且 MCP headers 优先级高于 httpx client 默认 headers。 [[39]](https://github.com/modelcontextprotocol/python-sdk/blob/main/src/mcp/client/streamable_http.py)

#### 4.2.2 POST 响应分流：202 / 404 / JSON / SSE
它在 POST 后： [[39]](https://github.com/modelcontextprotocol/python-sdk/blob/main/src/mcp/client/streamable_http.py)
- 若返回 202：认为 server 接受、无 body，直接返回。 [[39]](https://github.com/modelcontextprotocol/python-sdk/blob/main/src/mcp/client/streamable_http.py)
- 若返回 404 且请求是 JSON-RPC request：认为 session 终止（会发送 session terminated error，细节在截断外）。[[39]](https://github.com/modelcontextprotocol/python-sdk/blob/main/src/mcp/client/streamable_http.py)
- 否则按 `content-type`：  
  - `application/json` 走 JSON response 解析  
  - `text/event-stream` 走 SSE 事件流消费（并将 SSE `message` 事件解析为 JSON-RPC message）[[39]](https://github.com/modelcontextprotocol/python-sdk/blob/main/src/mcp/client/streamable_http.py)

#### 4.2.3 GET SSE stream：断线重连 + respect `retry`
`handle_get_stream` 会维护 `last_event_id` 与 `retry_interval_ms`，GET 断线后会等待 server 指定的 retry（若有），否则默认 1s，再重连；并限制最大重连次数。 [[39]](https://github.com/modelcontextprotocol/python-sdk/blob/main/src/mcp/client/streamable_http.py)

这与 2025-11-25 规范对 `retry` 的要求高度一致（规范说 client MUST respect retry）。[[6]](https://modelcontextprotocol.io/specification/2025-11-25/basic/transports)[[39]](https://github.com/modelcontextprotocol/python-sdk/blob/main/src/mcp/client/streamable_http.py)

#### 4.2.4 Resumption：用 `Last-Event-ID` 恢复 + priming 事件
`_handle_sse_event` 的逻辑很关键： [[39]](https://github.com/modelcontextprotocol/python-sdk/blob/main/src/mcp/client/streamable_http.py)
- 只处理 `event=="message"`  
- 若 `data` 为空：视作 priming event；若有 `id` 则回调更新 resumption token  
- 若有数据：把 data 解析为 JSON-RPC message，写入 read stream；若有 `id` 同样更新 token  
- 如果收到 JSON-RPC response/error，则认为该请求完成（返回 True）

它还提供 `_handle_resumption_request`：通过 GET + `Last-Event-ID` 进行恢复。 [[39]](https://github.com/modelcontextprotocol/python-sdk/blob/main/src/mcp/client/streamable_http.py)

#### 4.2.5 终止与资源管理
Python transport 基于 httpx-sse，具体关闭逻辑与异常处理都在 transport 内部封装，属于比较完整的工程实现。 [[39]](https://github.com/modelcontextprotocol/python-sdk/blob/main/src/mcp/client/streamable_http.py)

### 4.3 MCP TS SDK 客户端的“探测/回退”行为（有文档与 issue 线索，但 transport 源码未获取到）
MCP TS SDK 文档说明：要兼容 legacy SSE server，客户端应先尝试 Streamable HTTP，收到 4xx 再回退到 SSEClientTransport。 [[40]](https://github.com/modelcontextprotocol/typescript-sdk/blob/main/docs/client.md)  
TS SDK issue 还提到：StreamableHTTPClientTransport 可能会做一次“可选 SSE 连接尝试”，失败时不报错，但会造成监控噪音（希望可禁用）。[[38]](https://github.com/modelcontextprotocol/typescript-sdk/issues/926)  
另一个 issue 指出：客户端初始化期间会发 GET 去检查 SSE stream；若 server 不支持 SSE，应返回 405，否则可能初始化失败。 [[37]](https://github.com/modelcontextprotocol/typescript-sdk/issues/1150)

> 由于当前材料未直接打开 TS transport 源码，这些只能作为“行为线索”，你在实现服务端时要按规范返回 405/202 等，避免触发 client 探测超时或错误。 [[37]](https://github.com/modelcontextprotocol/typescript-sdk/issues/1150)[[38]](https://github.com/modelcontextprotocol/typescript-sdk/issues/926)[[5]](https://modelcontextprotocol.io/specification/2025-03-26/basic/transports)[[6]](https://modelcontextprotocol.io/specification/2025-11-25/basic/transports)

---

## 5) Claude API 的 MCP connector：对你实现 Streamable HTTP server 的额外约束

如果你的目标是“让 Claude Messages API 通过 MCP connector 直接连你的 MCP server”，那么 Anthropic 文档中明确了几条工程约束： [[3]](https://docs.anthropic.com/en/docs/agents-and-tools/mcp-connector)[[4]](https://platform.claude.com/docs/en/agents-and-tools/mcp-connector)

- MCP server 必须是 **公网可访问的 HTTPS URL**（`mcp_servers[].url` 必须以 `https://` 开头）。[[3]](https://docs.anthropic.com/en/docs/agents-and-tools/mcp-connector)[[4]](https://platform.claude.com/docs/en/agents-and-tools/mcp-connector)
- connector **支持 Streamable HTTP 与 SSE transports**。 [[3]](https://docs.anthropic.com/en/docs/agents-and-tools/mcp-connector)[[4]](https://platform.claude.com/docs/en/agents-and-tools/mcp-connector)
- 认证：支持 `authorization_token`（Bearer token），并建议按 MCP 规范/文档使用 OAuth；你需要自己完成 OAuth flow、负责 token 刷新，然后把 token 传给 connector。 [[3]](https://docs.anthropic.com/en/docs/agents-and-tools/mcp-connector)[[4]](https://platform.claude.com/docs/en/agents-and-tools/mcp-connector)
- 版本：需要 beta header（如 `"anthropic-beta": "mcp-client-2025-11-20"`），旧版本已 deprecated。 [[3]](https://docs.anthropic.com/en/docs/agents-and-tools/mcp-connector)[[4]](https://platform.claude.com/docs/en/agents-and-tools/mcp-connector)

并且在 Anthropic SDK issue 中能看到一些“平台侧连接行为”的线索：
- 有维护者提到：平台侧会先尝试 Streamable HTTP 再尝试 SSE；如果 MCP server 对 SSE 探测请求“完全不返回任何 HTTP 响应”，会导致超时并影响回退逻辑（甚至触发 500，这是平台 bug）。[[34]](https://github.com/anthropics/anthropic-sdk-typescript/issues/784)  
工程含义：**你的 server 对任何探测/不支持的 method，也应快速返回明确状态码（405/404），不要沉默挂起**。 [[34]](https://github.com/anthropics/anthropic-sdk-typescript/issues/784)

---

## 6) 工程化落地与迁移指南（从旧 SSE/HTTP+SSE 或从“纯 JSON”迁移）

### 6.1 从旧 HTTP+SSE（双端点）迁移到 Streamable HTTP（单端点）
旧版核心是：“先 GET SSE 拿到 endpoint event，再 POST 到另一个 endpoint”。[[7]](https://modelcontextprotocol.io/specification/2024-11-05/basic/transports)  
新版核心是：“同一 `/mcp` 上 POST/GET”。[[5]](https://modelcontextprotocol.io/specification/2025-03-26/basic/transports)[[6]](https://modelcontextprotocol.io/specification/2025-11-25/basic/transports)

迁移步骤建议（服务端）：
1) 先实现 Streamable HTTP 的 POST（至少 JSON-only），确保：
   - Accept 校验与 Content-Type 设置正确  
   - notification/response → 202 空 body  
   - request → 200 + `application/json`（先不做 SSE）[[5]](https://modelcontextprotocol.io/specification/2025-03-26/basic/transports)[[6]](https://modelcontextprotocol.io/specification/2025-11-25/basic/transports)
2) 再决定是否要 SSE：
   - 若需要通知/更丰富交互：实现 POST 返回 `text/event-stream`（或实现 GET SSE stream）[[5]](https://modelcontextprotocol.io/specification/2025-03-26/basic/transports)[[6]](https://modelcontextprotocol.io/specification/2025-11-25/basic/transports)
3) 如需断线恢复：引入 event store（至少按 stream 维度），实现 `Last-Event-ID` 的 GET 恢复语义。 [[5]](https://modelcontextprotocol.io/specification/2025-03-26/basic/transports)[[6]](https://modelcontextprotocol.io/specification/2025-11-25/basic/transports)

客户端兼容策略（MCP TS SDK 文档建议）：先尝试 Streamable HTTP；遇到 4xx 再回退 legacy SSE。 [[40]](https://github.com/modelcontextprotocol/typescript-sdk/blob/main/docs/client.md)  
平台侧（Anthropic connector）也有“先 streamable 后 SSE”的行为线索。 [[34]](https://github.com/anthropics/anthropic-sdk-typescript/issues/784)

### 6.2 从“纯 JSON（stateless）”升级到“支持 SSE/通知/恢复”
你需要补齐三块能力：

1) **会话与路由**
- 给客户端发 session id（初始化响应 header），并要求后续请求带 session id。 [[5]](https://modelcontextprotocol.io/specification/2025-03-26/basic/transports)[[6]](https://modelcontextprotocol.io/specification/2025-11-25/basic/transports)
- 解决多实例路由：粘滞会话、共享 session store、或 stateless 化（能力降级）。Java 生态里这正是最大争议点之一。 [[66]](https://github.com/modelcontextprotocol/java-sdk/issues/499)[[68]](https://github.com/modelcontextprotocol/java-sdk/issues/274)[[71]](https://github.com/modelcontextprotocol/java-sdk/issues/332)

2) **SSE 的工程正确性**
- 建连立刻 flush headers（Go 生态曾踩坑）。[[15]](https://github.com/modelcontextprotocol/go-sdk/issues/410)
- 发送 priming event（2025-11-25 推荐）[[6]](https://modelcontextprotocol.io/specification/2025-11-25/basic/transports)
- 发送 retry 并允许 polling 重连（2025-11-25 推荐）[[6]](https://modelcontextprotocol.io/specification/2025-11-25/basic/transports)

3) **resumability（可恢复）**
- 为 SSE event 分配 id（并编码足够信息来关联 stream；2025-11-25 建议 event id 能识别 originating stream）[[6]](https://modelcontextprotocol.io/specification/2025-11-25/basic/transports)
- 服务端能按 `Last-Event-ID` 重放该 stream 上未送达的消息。 [[5]](https://modelcontextprotocol.io/specification/2025-03-26/basic/transports)[[6]](https://modelcontextprotocol.io/specification/2025-11-25/basic/transports)
- 事件存储从内存升级为持久化（TS 示例的 InMemoryEventStore 明确只适合示例）。[[49]](https://raw.githubusercontent.com/modelcontextprotocol/typescript-sdk/refs/heads/main/examples/server/src/inMemoryEventStore.ts)

---

## 7) 生产级非功能性设计要点（在官方规范/工程线索基础上的落地建议）

### 7.1 连接与超时治理：用“polling SSE + retry”适配各种代理限制
官方规范给出的策略本质上是：**SSE 可以不是永远长连**。 [[6]](https://modelcontextprotocol.io/specification/2025-11-25/basic/transports)  
落地建议：
- 服务端开启 SSE 后立刻发 priming event + flush（避免客户端等头）。[[6]](https://modelcontextprotocol.io/specification/2025-11-25/basic/transports)[[15]](https://github.com/modelcontextprotocol/go-sdk/issues/410)
- 在空闲或压力大时，服务端主动发送 `retry: <ms>` 再断开，让客户端按 retry 重连（避免 LB/网关 idle timeout、避免单机连接数爆掉）。[[6]](https://modelcontextprotocol.io/specification/2025-11-25/basic/transports)
- 结合 event id + `Last-Event-ID` 保证“断开不丢消息”。[[5]](https://modelcontextprotocol.io/specification/2025-03-26/basic/transports)[[6]](https://modelcontextprotocol.io/specification/2025-11-25/basic/transports)

### 7.2 反向代理/网关（Nginx/Envoy/Cloudflare/ALB）注意事项
在已收集的官方文档中，**没有提供 Nginx/Envoy/Cloudflare 的具体参数示例**（例如关闭 buffering 的配置片段），这一点需要你基于所用网关文档自行配置（资料缺口）。[[5]](https://modelcontextprotocol.io/specification/2025-03-26/basic/transports)[[6]](https://modelcontextprotocol.io/specification/2025-11-25/basic/transports)[[12]](https://modelcontextprotocol.io/sdk/java/mcp-server)  
但从协议与已知坑可推导出“必须满足的网关行为”：
- **不要缓冲 SSE**：必须尽快把 headers 与 event 推到客户端，否则会复现 Go 的“客户端卡头部”现象。 [[15]](https://github.com/modelcontextprotocol/go-sdk/issues/410)
- **保留/透传关键 headers**：`Mcp-Session-Id`（或等价大小写）、`Last-Event-ID`、`Accept`、`Origin`，以及你自己的鉴权头（Bearer token）。[[5]](https://modelcontextprotocol.io/specification/2025-03-26/basic/transports)[[6]](https://modelcontextprotocol.io/specification/2025-11-25/basic/transports)
- **避免 301/307 重定向**：MCP client/connector 的探测逻辑可能不跟随或会造成超时；FastAPI 场景已见到 307 的现实问题。 [[21]](https://heeki.medium.com/building-an-mcp-server-as-an-api-developer-cfc162d06a83)
- **明确处理不支持的 method**：GET 不支持 SSE 就 405，DELETE 不支持就 405，不要让请求挂起（否则会导致 connector/客户端超时与回退失败）。[[5]](https://modelcontextprotocol.io/specification/2025-03-26/basic/transports)[[6]](https://modelcontextprotocol.io/specification/2025-11-25/basic/transports)[[34]](https://github.com/anthropics/anthropic-sdk-typescript/issues/784)

### 7.3 可观测性与对账
推荐你至少记录：
- session id、stream id（若有）、event id（若启用 resumability）
- 每次 POST 的 JSON-RPC id、method、耗时、状态码（202/200/400/404/405）
- SSE 断开次数、重连次数、按 `retry` 的等待时间分布

Go handler 本身就实现了 session 生命周期与超时控制的钩子结构；TS 示例有专门工具会周期性发通知，方便你压测与验证重连/恢复链路。 [[53]](https://raw.githubusercontent.com/modelcontextprotocol/go-sdk/v1.2.0/mcp/streamable.go)[[46]](https://raw.githubusercontent.com/modelcontextprotocol/typescript-sdk/refs/heads/main/examples/server/src/simpleStreamableHttp.ts)

### 7.4 安全
严格按规范做三件事： [[5]](https://modelcontextprotocol.io/specification/2025-03-26/basic/transports)[[6]](https://modelcontextprotocol.io/specification/2025-11-25/basic/transports)
- 校验 Origin（无效则 403）[[6]](https://modelcontextprotocol.io/specification/2025-11-25/basic/transports)
- 本地服务只绑定 127.0.0.1（避免暴露到内网/公网）[[5]](https://modelcontextprotocol.io/specification/2025-03-26/basic/transports)[[6]](https://modelcontextprotocol.io/specification/2025-11-25/basic/transports)
- 认证与授权（OAuth/Bearer token）；Anthropic connector 也把 OAuth token 作为主推荐路线。 [[3]](https://docs.anthropic.com/en/docs/agents-and-tools/mcp-connector)[[4]](https://platform.claude.com/docs/en/agents-and-tools/mcp-connector)[[9]](https://modelcontextprotocol.io/docs/learn/architecture)

---

## 8) 一份可操作的“实现清单”（按功能层级分阶段交付）

### Phase 0：最小可用（Stateless、JSON-only）
- 单端点 `/mcp`
- 仅实现 POST：
  - notification/response → 202 空 body  
  - request → 200 `application/json`（一次性返回 JSON-RPC response）
- GET/DELETE → 405  
参考：TS `simpleStatelessStreamableHttp.ts`。 [[51]](https://raw.githubusercontent.com/modelcontextprotocol/typescript-sdk/refs/heads/main/examples/server/src/simpleStatelessStreamableHttp.ts)

适用：只提供 tools、无通知/无 server request、追求极简与易扩展。

### Phase 1：Stateful（session），但仍 JSON-only
- 初始化时发 session id（或由 transport 自动生成并写 header）
- 后续请求必须带 session header，否则 400
- session 失效返回 404
参考：TS `jsonResponseStreamableHttp.ts` 的 session map 复用方式。 [[48]](https://raw.githubusercontent.com/modelcontextprotocol/typescript-sdk/refs/heads/main/examples/server/src/jsonResponseStreamableHttp.ts) 或 Go handler 的内建 session 管理。 [[53]](https://raw.githubusercontent.com/modelcontextprotocol/go-sdk/v1.2.0/mcp/streamable.go)

适用：需要会话状态，但还不需要通知/流式多消息。

### Phase 2：启用 SSE（POST->SSE 或 GET SSE）
- GET 支持 `text/event-stream`（不支持则必须 405）[[5]](https://modelcontextprotocol.io/specification/2025-03-26/basic/transports)[[6]](https://modelcontextprotocol.io/specification/2025-11-25/basic/transports)
- 建连立即 flush headers（Go 已验证这是必须的）[[15]](https://github.com/modelcontextprotocol/go-sdk/issues/410)
- 发 priming event（2025-11-25 推荐）[[6]](https://modelcontextprotocol.io/specification/2025-11-25/basic/transports)
- 支持 server 通知（notifications）与可能的 server request

适用：需要 server→client 通知、任务进度、异步事件。

### Phase 3：Resumability（断线恢复）
- event id 设计：能定位到 stream（2025-11-25 建议）[[6]](https://modelcontextprotocol.io/specification/2025-11-25/basic/transports)
- 持久化 event store（TS 的 InMemoryEventStore 只作示例）[[49]](https://raw.githubusercontent.com/modelcontextprotocol/typescript-sdk/refs/heads/main/examples/server/src/inMemoryEventStore.ts)
- GET + `Last-Event-ID` 重放同一 stream 的后续事件（不得跨 stream）[[5]](https://modelcontextprotocol.io/specification/2025-03-26/basic/transports)[[6]](https://modelcontextprotocol.io/specification/2025-11-25/basic/transports)

适用：移动网络、长任务、代理容易断链的场景。

---

## 9) 你接下来最应该补读/验证的“关键源码点”（因为当前资料存在缺口）

1) **TS SDK transport 内部实现**：`NodeStreamableHTTPServerTransport` 如何写 SSE、如何 flush、如何设置 `retry:`、如何处理 `Last-Event-ID` 与 event store（当前材料未拿到 transport 核心源码）。[[45]](https://raw.githubusercontent.com/modelcontextprotocol/typescript-sdk/refs/heads/main/docs/server.md)[[46]](https://raw.githubusercontent.com/modelcontextprotocol/typescript-sdk/refs/heads/main/examples/server/src/simpleStreamableHttp.ts)[[47]](https://raw.githubusercontent.com/modelcontextprotocol/typescript-sdk/refs/heads/main/examples/client/src/simpleStreamableHttp.ts)  
2) **Java SDK**：Servlet/WebFlux/WebMVC server transport 的 SSE 输出与 flush 细节、以及 session store 的可插拔能力（issues 里反映需求强烈，但缺少官方最终形态的清晰示例）。[[66]](https://github.com/modelcontextprotocol/java-sdk/issues/499)[[67]](https://github.com/modelcontextprotocol/java-sdk/issues/738)[[62]](https://github.com/modelcontextprotocol/java-sdk/issues/763)  
3) **你要接 Anthropic MCP connector**：务必做“探测请求快速响应”，并保证 HTTPS、避免重定向、GET/DELETE 返回 405 的语义正确；否则可能触发平台侧超时/回退问题。 [[34]](https://github.com/anthropics/anthropic-sdk-typescript/issues/784)[[3]](https://docs.anthropic.com/en/docs/agents-and-tools/mcp-connector)[[4]](https://platform.claude.com/docs/en/agents-and-tools/mcp-connector)

---

如果你愿意把“你准备采用的栈（例如 Node+Express / Go / Java WebFlux / Python FastAPI）”以及“你是否需要通知、是否需要 resumability、是否需要多实例部署”这三点说清楚，我可以基于上面规范与各 SDK 的已知实现模式，给一份更贴近你场景的**端到端工程方案**（包含路由、header、状态码矩阵、SSE flush/keepalive 策略、以及多实例下的 session/event store 设计）。
