Query ID: 64
============================================================

QUESTION:
Regarding the attitude control problem for UAVs, most open-source flight controllers currently implement cascaded PID control algorithms. However, a single set of PID controller parameters typically performs well only under specific flight conditions. In practical applications, UAVs operate across diverse flight states. What methods can be employed to enhance the actual control performance of PID algorithms, and how should PID parameters be optimally selected?

============================================================

RESEARCH TASKS (6 total):
  #1: Research limitations of cascaded PID attitude/rate controllers for UAVs across varying flight regimes (hover, aggressive maneuvers, forward flight, payload changes, battery voltage sag, wind) and identify key performance metrics used in literature/practice to quantify real control performance (tracking, bandwidth, overshoot, settling time, disturbance rejection, actuator saturation, energy use). Provide UAV-specific examples and references (2015-2026).
  #2: Research practical PID augmentation techniques used in modern open-source autopilots (ArduPilot, PX4, Betaflight/INAV) to improve real-world attitude control performance: anti-windup, derivative filtering, feedforward, notch/harmonic filters, setpoint shaping, integrator gating, saturation handling, disturbance observers, and how these interact with tuning. Include where these appear in code/docs and any empirical results.
  #3: Research methods to enhance PID performance across diverse flight states: gain scheduling variables/methods, adaptive/auto-tuning approaches (relay tuning, FRF identification, extremum-seeking, MRAC, ILC, Bayesian optimization), and model-based/robust approaches to select 'optimal' PID parameters (linearization, loop-shaping, margins, H-infinity ideas, LQR-to-PID, constraints from actuator limits/noise). Focus on UAV attitude control and 2018-2026 literature and best-practice workflows.
  #4: Research gain scheduling and multi-condition tuning mechanisms actually available in ArduPilot and PX4 (and optionally Betaflight/INAV): airspeed scaling for fixed-wing, throttle-based attenuation/TPA, voltage sag compensation, motor thrust curve modeling, landed/ground resonance gain reduction, and any parameter sets or tables used for scheduling. Provide citations from docs/code and explain what variables are used and how smooth transitions are ensured.
  #5: Research practical PID auto-tuning workflows and safety constraints in open-source UAV autopilots (PX4 Autotune, ArduPilot Autotune, Betaflight/INAV autotune features). Focus on what system ID methods they use (frequency response, relay oscillations), what regime they tune for (hover, etc.), safety guards (rate limits, excitation, abort), and limitations (flexible frames, delays, wind). Provide doc/code references.
  #6: Research validation and deployment methodology for PID/scheduled/adaptive attitude control on UAVs: standardized flight-test maneuvers and metrics, SITL/HIL/real flight correlation, logging/FFT tools, regression metrics, and guidelines for choosing between fixed PID, scheduled PID, and adaptive/learning approaches for different UAV classes/missions (multirotor, fixed-wing, VTOL) as of 2020-2026 literature and practice. Include references to open-source tooling and academic best practices.

============================================================

ANSWER:
### 1) Why a single PID tune “only works in one condition” (what actually changes)

Even if the flight controller architecture is the same (outer attitude loop → inner rate loop), the *effective plant seen by the rate PID* changes substantially across flight states because of:

- **Actuator effectiveness changes**  
  - Multirotors: thrust vs command is nonlinear and voltage-dependent; high-throttle regions often behave differently from hover. PX4 explicitly notes tuning is optimized around hover thrust and oscillations can appear toward full throttle unless thrust nonlinearity is modeled (THR_MDL_FAC) [[2]](https://docs.px4.io/main/en/config_mc/pid_tuning_guide_multicopter). ArduPilot likewise stresses that a nonlinear thrust curve can prevent a good tune and can even cause instability [[38]](https://ardupilot.org/copter/docs/setting-up-for-tuning.html), and provides thrust linearization parameters (e.g., MOT_THST_EXPO) [[40]](https://ardupilot.org/copter/docs/motor-thrust-scaling.html).  
  - Fixed-wing: control surface effectiveness scales with airspeed/dynamic pressure; ArduPilot explicitly applies **airspeed-based gain scaling** (Speed Scaling) so that gains don’t cause oscillations at high speed and don’t become too weak at low speed [[36]](https://ardupilot.org/plane/docs/airspeed-parameters-setup.html), [[35]](https://ardupilot.org/plane/docs/new-roll-and-pitch-tuning.html).

- **Saturation, slew-rate, and allocation constraints**  
  PX4 documents that the rate controller output is limited in control allocation (typically \[-1, 1]) and integral authority is limited to avoid windup [[1]](https://docs.px4.io/main/en/flight_stack/controller_diagrams). PX4 autotune also lists saturation and slew-rate among unmodeled effects that can make an autotuned system oscillate [[3]](https://docs.px4.io/main/en/config/autotune_mc).

- **Noise/latency changes with throttle, airframe vibration, and filtering**  
  Control latency and filtering trade off directly with achievable P/D gains: PX4 quantifies that a 30 Hz low-pass can add ~8 ms delay, 60 Hz ~3.8 ms, 120 Hz ~1.9 ms [[17]](https://docs.px4.io/main/en/config_mc/filter_tuning). ArduPilot notes low gyro LPF cutoffs add phase lag and reduce how aggressively you can tune; harmonic notch filtering can allow higher LPF cutoffs and thus a tighter tune [[16]](https://ardupilot.org/copter/docs/common-imu-notch-filtering.html).  

- **Disturbances and model mismatch** (wind, payloads, aggressive maneuvers)  
  Literature emphasizes that PID disturbance rejection scales with gains, which are limited by sensor update rate/noise; integrators can be slow to compensate persistent wind [[6]](https://www.sciencedirect.com/science/article/abs/pii/S0967066118300030). Aggressive maneuvers violate common simplifying assumptions (small angles, negligible motor dynamics, no disturbances), degrading performance unless those effects are compensated [[7]](https://www.researchgate.net/publication/328171772_Disturbance_observer-based_quadrotor_attitude_tracking_control_for_aggressive_maneuvers). Payload changes (including suspended payloads) alter inertia/torque needs and introduce disturbances [[7]](https://www.researchgate.net/publication/328171772_Disturbance_observer-based_quadrotor_attitude_tracking_control_for_aggressive_maneuvers), [[8]](https://onlinelibrary.wiley.com/doi/10.1155/2019/6460156).

**Practical metrics to define “actual control performance” across regimes** (used in both open-source practice and literature):

- **Tracking**: rate setpoint vs measured rate; attitude setpoint vs attitude (PX4 and ArduPilot both recommend log-based tracking checks) [[2]](https://docs.px4.io/main/en/config_mc/pid_tuning_guide_multicopter), [[4]](https://ardupilot.org/copter/docs/tuning.html).  
- **Transient quality**: overshoot, oscillations, “stabilize within N oscillations” (PX4 uses “within 2 oscillations” as a readiness criterion) [[3]](https://docs.px4.io/main/en/config/autotune_mc).  
- **Disturbance rejection**: maximum deviation under gusts (e.g., 10 m/s windtunnel entry/exit test: 21 cm vs 151 cm max deviation) [[6]](https://www.sciencedirect.com/science/article/abs/pii/S0967066118300030).  
- **Saturation/authority usage**: time spent saturated, integrator hitting limits, allocator clipping [[1]](https://docs.px4.io/main/en/flight_stack/controller_diagrams).  
- **Actuator/thermal “cost”**: twitchy motors / hot motors as symptom of excessive D/noise amplification [[2]](https://docs.px4.io/main/en/config_mc/pid_tuning_guide_multicopter); power/energy metrics are explicitly studied in robust PID work [[9]](https://www.sciencedirect.com/science/article/abs/pii/S001905781930391X).  
- **Envelope robustness**: performance retention with mass changes and wind (tripled mass + strong wind in tests with PID augmentation) [[8]](https://onlinelibrary.wiley.com/doi/10.1155/2019/6460156).

---

## 2) Methods that improve real-world PID performance **without changing the overall cascaded PID structure**

These are the “high leverage” improvements that most directly expand the range of conditions where one tune performs well.

### 2.1 Reduce plant nonlinearity first: thrust/actuator linearization and compensation
If the actuator mapping changes with throttle or voltage, you are effectively “gain scheduling the plant” unintentionally—your fixed PID gains won’t behave consistently.

- **PX4 thrust curve modeling (THR_MDL_FAC)**  
  PX4 provides an explicit static thrust model blending linear and quadratic mappings:  
  \[
  \text{rel\_thrust} = f \cdot \text{rel\_signal}^2 + (1-f)\cdot \text{rel\_signal}
  \]
  with typical values 0.3–0.5, and warns oscillations may appear at high throttle if the mapping isn’t modeled [[2]](https://docs.px4.io/main/en/config_mc/pid_tuning_guide_multicopter). Changing this may require re-tuning the rate controller [[2]](https://docs.px4.io/main/en/config_mc/pid_tuning_guide_multicopter).

- **ArduPilot motor thrust scaling (MOT_THST_EXPO, MOT_SPIN_MAX)**  
  ArduPilot documents thrust scaling to linearize thrust response; default expo often works, but ESCs with their own linearization may require much lower expo values (0–0.2) to avoid stability issues [[40]](https://ardupilot.org/copter/docs/motor-thrust-scaling.html). Internally, ArduPilot’s voltage/thrust scaling uses filtered battery voltage ratio and an expo-based blend for maximum lift and scaling [[41]](https://github.com/ArduPilot/ardupilot/issues/23575).

- **Voltage sag handling**  
  ArduPilot highlights voltage sag as a common cause of nonlinear thrust curves and recommends configuring battery voltage range (MOT_BAT_VOLT_MAX/MIN) and sag-compensated voltage usage for tuning computations [[38]](https://ardupilot.org/copter/docs/setting-up-for-tuning.html). (If voltage sag changes thrust-per-command across the flight, your “best” PID gains also change.)

**Rule of thumb**: if your tune is great at hover but oscillates at high throttle (or vice versa), fix **actuator linearization** before trying “clever PID tricks.” PX4 explicitly frames THR_MDL_FAC as the fix for high-thrust oscillations that appear when a hover-optimized tune is pushed to full throttle [[2]](https://docs.px4.io/main/en/config_mc/pid_tuning_guide_multicopter).

---

### 2.2 Anti-windup and saturation-aware integration (mandatory for envelope robustness)
Saturation is common in gusts, aggressive turns, payload flight, and low-voltage states. If the integrator keeps accumulating when actuators can’t follow, you get overshoot and long recovery.

Open-source stacks implement several proven strategies:

- **Integral authority limits**  
  PX4 rate controller limits integral authority to prevent windup and notes outputs are limited by control allocation [[1]](https://docs.px4.io/main/en/flight_stack/controller_diagrams). PX4 exposes per-axis integrator limits (MC_RR_INT_LIM / MC_PR_INT_LIM / MC_YR_INT_LIM) [[18]](https://github.com/PX4/PX4-Autopilot/blob/master/src/modules/mc_rate_control/mc_rate_control_params.c).

- **Conditional integration (“clamping”)**  
  ArduPilot AC_PID explicitly implements conditional integration: when `limit` is true, the integrator may shrink but not grow (classic anti-windup) and is constrained by IMAX [[13]](https://github.com/ArduPilot/ardupilot/blob/master/libraries/AC_PID/AC_PID.cpp).

- **Back-calculation anti-windup**  
  INAV’s multirotor controller includes an anti-windup term based on the difference between limited and unlimited output:  
  \[
  I \mathrel{+}= (k_I \cdot \text{itermErrorRate} \cdot dt) + ((u_{\text{limited}} - u)\cdot k_T \cdot dt)
  \]
  [[22]](https://github.com/iNavFlight/inav/blob/master/docs/INAV%20PID%20Controller.md).

- **Integrator gating/leak based on state**  
  ArduPilot documents “leaky integrator” and landing/takeoff detection to prevent I-term buildup on the ground (which can tip vehicles) and to manage hover trim retention [[14]](https://ardupilot.org/copter/docs/traditional-helicopter-tuning-other-topics.html).  
  ArduPilot also provides smooth I-term decay for transitions (“decays I-term to zero over ~0.5s”) [[12]](https://github.com/ArduPilot/ardupilot/blob/master/libraries/AC_AttitudeControl/AC_AttitudeControl.h).

**Practical guidance**:
- Use *enough* integrator to remove steady biases (wind, CG offsets), but treat I as **disturbance compensation**, not as your primary tracking tool.  
- Ensure the I-term strategy is consistent with allocator limits; if the allocator clips frequently, improve actuator authority (prop/motor sizing, voltage, mixer priorities) or reduce demanded dynamics (rate limits/accel limits), otherwise I-term tuning becomes regime-specific.

---

### 2.3 Derivative done right: “D on measurement” + filtering + notch strategy
A high-performing rate loop is almost always limited by noise/latency, not by “not enough D gain.”

- **D on measurement / avoid derivative kick**  
  PX4 explicitly places D on the feedback path to avoid derivative kick [[2]](https://docs.px4.io/main/en/config_mc/pid_tuning_guide_multicopter). INAV computes D only from gyro measurement (not error derivative) [[22]](https://github.com/iNavFlight/inav/blob/master/docs/INAV%20PID%20Controller.md).

- **Dedicated derivative filtering**  
  PX4 documents a clear pipeline: gyro notch + LPF for P/I, then derivative computed and LPF’d (IMU_DGYRO_CUTOFF) for D using filtered angular acceleration [[1]](https://docs.px4.io/main/en/flight_stack/controller_diagrams), [[17]](https://docs.px4.io/main/en/config_mc/filter_tuning).  
  ArduPilot AC_PID offers separate LPFs for target (FLTT), error (FLTE), and derivative (FLTD) [[13]](https://github.com/ArduPilot/ardupilot/blob/master/libraries/AC_PID/AC_PID.cpp).

- **Notch / harmonic notch / dynamic notch**  
  ArduPilot’s harmonic notch filtering is positioned as enabling higher gyro LPF cutoffs (less phase lag) and therefore tighter tuning [[16]](https://ardupilot.org/copter/docs/common-imu-notch-filtering.html). It supports multiple modes including throttle-based, RPM sensor / ESC telemetry based, and FFT-based tracking (mode 4, CPU permitting) [[16]](https://ardupilot.org/copter/docs/common-imu-notch-filtering.html).  
  PX4 documents static notches and dynamic notches (ESC RPM or onboard FFT), with the goal of enabling higher LPF cutoffs and lower latency [[17]](https://docs.px4.io/main/en/config_mc/filter_tuning).

**Practical workflow implication** (very important):
1. Fix mechanical vibration first (filters are not a substitute).  
2. Use notches to remove narrow motor peaks.  
3. Then raise gyro LPF cutoffs to reduce latency (PX4 explicitly links lower latency to the ability to increase P gains) [[17]](https://docs.px4.io/main/en/config_mc/filter_tuning).  
4. Then tune P/D.  

This ordering prevents the common failure mode: “increase D to fight overshoot → amplify noise → add more filtering → add phase lag → destabilize at higher throttle.”

---

### 2.4 Feedforward and setpoint shaping: improve tracking *without pushing feedback gains*
This is one of the most effective ways to make one tune work across multiple regimes because it reduces reliance on high P/D.

- **Explicit feedforward terms in open-source stacks**  
  PX4 has per-axis rate feedforward parameters MC_ROLLRATE_FF / MC_PITCHRATE_FF / MC_YAWRATE_FF and states they “improve tracking performance” [[18]](https://github.com/PX4/PX4-Autopilot/blob/master/src/modules/mc_rate_control/mc_rate_control_params.c).  
  ArduPilot AC_PID includes FF (proportional to target) and D_FF (proportional to target derivative) along with target filtering [[13]](https://github.com/ArduPilot/ardupilot/blob/master/libraries/AC_PID/AC_PID.cpp).  
  Betaflight replaced older D setpoint weighting with a dedicated feedforward system; it emphasizes that feedforward provides fast response without waiting for error to build, and reduces the need to keep raising P just to get responsiveness [[19]](https://betaflight.com/docs/wiki/tuning/3-5-tuning-notes).  
  INAV includes a “Control Derivative” term (setpoint derivative) equivalent to Betaflight feedforward [[22]](https://github.com/iNavFlight/inav/blob/master/docs/INAV%20PID%20Controller.md).

- **Setpoint shaping / input smoothing / acceleration limits**  
  ArduPilot explicitly runs pilot commands through first-order shaping and acceleration limiting to create a kinematically consistent attitude target; it warns that disabling rate feedforward can produce noticeable lag [[15]](https://ardupilot.org/dev/docs/copter-adding-custom-controller.html). It exposes ATC_INPUT_TC (input time constant) and acceleration limit parameters in the attitude controller layer [[12]](https://github.com/ArduPilot/ardupilot/blob/master/libraries/AC_AttitudeControl/AC_AttitudeControl.h), [[14]](https://ardupilot.org/copter/docs/traditional-helicopter-tuning-other-topics.html).  
  PX4 attitude controller saturates rate commands, an important nonlinearity that interacts with outer-loop gain selection [[1]](https://docs.px4.io/main/en/flight_stack/controller_diagrams).

**Practical guidance**:
- Use feedforward to get crisp tracking at both low and high thrust without over-aggressive P.  
- Use setpoint shaping (rate/accel limits and input time constants) to avoid commanding dynamics that are unattainable in low-voltage/heavy-payload/high-drag states. This directly improves “actual performance” because it reduces time in saturation and reduces integrator stress.

---

### 2.5 Slew limiting, PD limiting, and gain reduction mechanisms (automatic “self-protection”)
These features prevent oscillation amplification in regimes where dynamics change.

- ArduPilot AC_PID includes **SMAX slew limiting**, which reduces effective P+D when the commanded slew exceeds a limit (explicitly framed as limiting high-frequency oscillations from excessive gain) [[13]](https://github.com/ArduPilot/ardupilot/blob/master/libraries/AC_PID/AC_PID.cpp), and PDMX limiting on the P+D sum [[13]](https://github.com/ArduPilot/ardupilot/blob/master/libraries/AC_PID/AC_PID.cpp).  
- ArduPilot Plane includes a “Slew Rate Limiter” concept that reduces loop gains when servo slew-rate limits are exceeded [[35]](https://ardupilot.org/plane/docs/new-roll-and-pitch-tuning.html).  
- PX4 fixed-wing includes **Gain Compression**: automatically reduces angular-rate PID gains when oscillations are detected using a band-pass-filtered signal, never increases above nominal gains, and is bounded by a minimum [[44]](https://docs.px4.io/main/en/features_fw/gain_compression). PX4 recommends disabling it during manual tuning to avoid “over-tuning,” then re-enabling after [[45]](https://docs.px4.io/main/en/config_fw/pid_tuning_guide_fixedwing).

These mechanisms are especially useful when you cannot precisely schedule gains for every condition, but you still want protection against worst-case oscillation regimes (e.g., airspeed sensor failure, CG shift, icing).

---

## 3) Gain scheduling: the main way to keep PID good across “diverse flight states”

A single fixed gain set is rarely optimal across a wide envelope; **gain scheduling** is the standard practical solution when you want to keep the PID structure.

### 3.1 What to schedule (most useful variables)

**Fixed-wing**
- **Airspeed / dynamic pressure (q̄)**: primary driver of control effectiveness.  
  ArduPilot explicitly speed-scales stabilization gains based on airspeed and uses SCALING_SPEED with AIRSPEED_MIN/MAX to define the schedule range [[36]](https://ardupilot.org/plane/docs/airspeed-parameters-setup.html), [[35]](https://ardupilot.org/plane/docs/new-roll-and-pitch-tuning.html).  
  (If airspeed sensing is absent, ArduPilot uses an estimate from GPS/IMU/position changes, but warns it can be dangerous in some wind scenarios if used more broadly) [[36]](https://ardupilot.org/plane/docs/airspeed-parameters-setup.html).

**Multirotor**
- **Throttle / thrust level**: proxy for rotor speed, vibration spectrum, and effective torque authority.  
  Betaflight’s TPA (Throttle PID Attenuation) reduces P/D gains as throttle rises above a breakpoint, ramping smoothly to full attenuation at full throttle [[47]](https://betaflight.com/docs/development/PID-tuning). This is specifically intended for “oscillations only at high throttle” [[20]](https://betaflight.com/docs/wiki/guides/current/PID-Tuning-Guide).  
  PX4 does not document a TPA-style gain schedule in the provided sources; instead it documents thrust curve modeling to address high-throttle oscillations [[2]](https://docs.px4.io/main/en/config_mc/pid_tuning_guide_multicopter).

- **Battery voltage / internal resistance estimate**: proxy for thrust authority and motor dynamics changes.  
  ArduPilot emphasizes voltage sag’s impact on thrust curve linearity and provides voltage range and sag-compensation options [[38]](https://ardupilot.org/copter/docs/setting-up-for-tuning.html); internal implementation uses filtered voltage ratio in thrust scaling [[41]](https://github.com/ArduPilot/ardupilot/issues/23575). (Even if you don’t schedule PID gains directly, compensating thrust mapping reduces “implicit gain scheduling.”)

- **Mass / inertia estimate / payload state**: strong effect on angular acceleration for a given torque.  
  Academic adaptive PID work explicitly schedules gains based on mass estimated online via WRLS [[29]](https://reference-global.com/article/10.2478/ama-2024-0004), and other works explicitly target mass variation and wind as disturbance sources that degrade baseline PID [[8]](https://onlinelibrary.wiley.com/doi/10.1155/2019/6460156).

**Across types**
- **Detected oscillation / vibration metric**: schedule gain reduction or filtering aggressiveness.  
  PX4 gain compression reduces gains upon oscillation detection [[44]](https://docs.px4.io/main/en/features_fw/gain_compression).  
  Dynamic notch filters (ArduPilot, PX4, Betaflight) effectively schedule filtering based on RPM/FFT-detected peaks [[16]](https://ardupilot.org/copter/docs/common-imu-notch-filtering.html), [[17]](https://docs.px4.io/main/en/config_mc/filter_tuning), [[19]](https://betaflight.com/docs/wiki/tuning/3-5-tuning-notes).

### 3.2 How to schedule (so transitions are stable and smooth)

A practical scheduling design should:
- Use **continuous interpolation** (avoid hard switching).  
  Betaflight TPA is explicitly a smooth ramp from breakpoint to full throttle [[47]](https://betaflight.com/docs/development/PID-tuning).  
  Thrust curve models (PX4 THR_MDL_FAC, ArduPilot expo curves) are continuous mappings [[2]](https://docs.px4.io/main/en/config_mc/pid_tuning_guide_multicopter), [[40]](https://ardupilot.org/copter/docs/motor-thrust-scaling.html).

- Schedule **the most sensitive gains first**:
  - Typically P and D (and feedforward) benefit most from scheduling; I is often kept more conservative or scheduled slowly with strong anti-windup.  
  - Also schedule *rate/accel limits* and *integrator limits* if actuator authority changes drastically (PX4 exposes integrator limits and warns about saturation/windup) [[1]](https://docs.px4.io/main/en/flight_stack/controller_diagrams), [[18]](https://github.com/PX4/PX4-Autopilot/blob/master/src/modules/mc_rate_control/mc_rate_control_params.c).

- Ensure **bandwidth separation** in cascaded loops remains valid across the envelope.  
  PX4 troubleshooting notes slow oscillations can mean the attitude loop is too fast relative to the rate loop, especially on large platforms [[3]](https://docs.px4.io/main/en/config/autotune_mc). If you schedule inner-loop gains, you may need to schedule outer-loop gains or caps too.

---

## 4) Adaptive / auto-tuning approaches (reduce manual tuning and adapt to changing conditions)

### 4.1 Onboard autotune in open-source flight controllers (what they do well, and what they don’t)

**PX4 Autotune**  
- Designed to tune rate and attitude controllers (critical for stability) [[3]](https://docs.px4.io/main/en/config/autotune_mc).  
- Explicitly warns that it’s performed in-flight and requires the airframe to already fly well enough to tolerate disturbances [[3]](https://docs.px4.io/main/en/config/autotune_mc).  
- Uses injected identification signals (step or sine sweeps are parameterized; start/end frequencies and maneuver time per axis are exposed) [[52]](https://docs.px4.io/main/en/advanced_config/parameter_reference).  
- Has explicit safety and abort logic: sequence abort on timeout, mode change, or pilot intervention; and an optional “apply in-air” mode performs a 4-second stability test and reverts gains if unstable [[3]](https://docs.px4.io/main/en/config/autotune_mc), [[53]](https://github.com/PX4/PX4-Autopilot/raw/refs/heads/main/src/modules/mc_autotune_attitude_control/mc_autotune_attitude_control.cpp).  
- Limitations are stated clearly: model assumes linear, SISO, limited complexity (2 poles/2 zeros), and can fail with frame flexibility, delays, saturation, slew-rate effects [[3]](https://docs.px4.io/main/en/config/autotune_mc).

**ArduPilot Copter AutoTune**  
- Tunes Stabilize P, Rate P and D, and max rotational accelerations to maximize response without overshoot [[56]](https://ardupilot.org/copter/docs/autotune.html).  
- Also strongly warns it can produce unflyable gains; recommends good notch filtering and QuikTune beforehand [[56]](https://ardupilot.org/copter/docs/autotune.html).  
- Lists practical failure drivers: wind, gyro noise, incorrect thrust expo, flexible frame/mounts, too low spin min, overloaded prop/motor [[56]](https://ardupilot.org/copter/docs/autotune.html).  
- Provides pilot override behavior and reversion to original gains while repositioning; tuned gains saved only after landing/disarming under explicit conditions [[56]](https://ardupilot.org/copter/docs/autotune.html), [[57]](https://github.com/ArduPilot/ardupilot/raw/refs/heads/master/libraries/AC_AutoTune/AC_AutoTune.cpp).

**INAV fixed-wing Autotune**  
- Pilot-input-driven learning of PIFF gains, inspired by ArduPilot Plane [[61]](https://github.com/iNavFlight/inav/blob/master/docs/Autotune%20-%20fixedwing.md).  
- Explicitly warns not to land in Autotune mode because landing performance limits can be misinterpreted as insufficient gains [[61]](https://github.com/iNavFlight/inav/blob/master/docs/Autotune%20-%20fixedwing.md).

**Betaflight**  
- Maintainers state there is **no autotune capability**; prior attempts were removed because they “never actually worked” consistently across platforms [[59]](https://github.com/betaflight/betaflight/issues/6857), [[60]](https://github.com/betaflight/betaflight/issues/339).  
  In practice, Betaflight tuning relies on blackbox logs and manual tuning/analysis.

### 4.2 Research-grade adaptive/learning optimization options (what can work, and the safety reality)

These methods can produce better multi-condition performance than fixed gains, but they introduce requirements: safe exploration, bounded updates, sufficient excitation, and clear abort logic.

- **System-ID + robust tuning rules** (structured, engineering-friendly)  
  One cascaded PID autotuning method identifies frequency response via relay feedback, fits a simple “integrator + delay” model, then computes robust PID gains based on a chosen closed-loop time constant factor [[28]](https://www.mdpi.com/2072-4292/14/7/1540).  
  This is conceptually close to why PX4 autotune constrains model complexity and includes delay-like behavior [[3]](https://docs.px4.io/main/en/config/autotune_mc).

- **Gain scheduling with online parameter estimation**  
  Adaptive PID work estimates mass online using WRLS and schedules gains accordingly; it emphasizes differential filtering to reduce measurement noise for derivative/identification signals [[29]](https://reference-global.com/article/10.2478/ama-2024-0004).

- **Bayesian optimization / safe Bayesian optimization**  
  SafeOpt is explicitly intended to optimize controller parameters subject to safety constraints (originating in safe quadrotor controller optimization) [[32]](https://safeopt.readthedocs.io/).  
  A 2025 preprint proposes heteroscedastic Bayesian optimization for tuning cascaded PID gains and reports significant accuracy improvements, but as an arXiv preprint those results should be treated as preliminary [[27]](https://arxiv.org/html/2512.24249v1).

- **Gradient-based auto-tuning with sensitivity propagation**  
  DiffTune frames controller tuning as differentiable optimization and reports large tracking error reduction in few trials on a quadrotor experiment, while noting model mismatch can bias gradients and proposing robustness augmentation to mitigate that [[31]](https://arxiv.org/html/2209.10021v3).

- **Iterative Learning Control (ILC)** (best when missions repeat)  
  PID-type ILC approaches are proposed to improve tracking precision over repeated trajectories and handle uncertainties; fuzzy tuning is used to speed learning and reduce disturbance-induced chattering in simulation [[33]](https://www.mdpi.com/1424-8220/19/1/24).  
  A 2025 experimental ILC approach highlights the importance of using a stabilizing baseline controller first to avoid crashes during learning iterations [[34]](https://www.cambridge.org/core/journals/robotica/article/experimental-iterative-learning-control-of-a-quadrotor-in-flight-a-derivation-of-the-statedependent-riccati-equation-method/C07D479E0EB52929C55752850E72BA56).

- **Robust/adaptive augmentation (e.g., L1 adaptive + NN) for hard regimes like transition**  
  Tail-sitter transition work proposes L1 neural network adaptive control associated with PID to handle time-varying disturbances and changing equilibrium points during transition [[25]](https://www.sciencedirect.com/science/article/pii/S1000936123001176).

**Bottom line**: in real UAV deployments, adaptive/learning tuning is typically layered on top of strong safety mechanisms (bounded gain updates, saturation-aware anti-windup, abort/rollback, and often “safe exploration” constraints) [[32]](https://safeopt.readthedocs.io/), [[34]](https://www.cambridge.org/core/journals/robotica/article/experimental-iterative-learning-control-of-a-quadrotor-in-flight-a-derivation-of-the-statedependent-riccati-equation-method/C07D479E0EB52929C55752850E72BA56), mirroring the kind of guardrails PX4 and ArduPilot already embed in their autotune implementations [[3]](https://docs.px4.io/main/en/config/autotune_mc), [[57]](https://github.com/ArduPilot/ardupilot/raw/refs/heads/master/libraries/AC_AutoTune/AC_AutoTune.cpp).

---

## 5) How to choose PID parameters “optimally” (a robust, UAV-practical workflow)

“Optimal” should mean: meets performance targets **across a set of operating points** with acceptable stability margins, saturation usage, and noise/thermal cost—not just “best hover feel.”

### 5.1 Use the cascaded structure correctly (inner-first, bandwidth separation)
Both PX4 and ArduPilot architectures are cascaded: attitude loop generates rate setpoints; rate loop tracks rates [[1]](https://docs.px4.io/main/en/flight_stack/controller_diagrams), [[11]](https://ardupilot.org/dev/docs/apmcopter-programming-attitude-control-2.html). This implies:

1) **Tune the rate loop first**, because it defines the inner plant seen by the attitude loop.  
2) **Then tune attitude P** (often only P is exposed/needed) [[1]](https://docs.px4.io/main/en/flight_stack/controller_diagrams), [[2]](https://docs.px4.io/main/en/config_mc/pid_tuning_guide_multicopter).  
3) Maintain bandwidth separation: if outer loop is too fast relative to inner, you get slow oscillations; PX4 explicitly attributes this to attitude loop too fast vs rate loop and recommends reducing attitude gains (or adjusting rate gains) [[3]](https://docs.px4.io/main/en/config/autotune_mc).

### 5.2 Define objective metrics and constraints up front
Pick metrics that reflect your mission envelope:

- Hover precision: RMS/MAE of rate and attitude tracking (log-based) [[2]](https://docs.px4.io/main/en/config_mc/pid_tuning_guide_multicopter), [[4]](https://ardupilot.org/copter/docs/tuning.html), [[10]](https://pmc.ncbi.nlm.nih.gov/articles/PMC12332915/).  
- Aggressive maneuvering: overshoot and settling after step-like inputs / flips [[2]](https://docs.px4.io/main/en/config_mc/pid_tuning_guide_multicopter), [[7]](https://www.researchgate.net/publication/328171772_Disturbance_observer-based_quadrotor_attitude_tracking_control_for_aggressive_maneuvers).  
- Wind/payload: maximum deviation and recovery time under gusts or load changes [[6]](https://www.sciencedirect.com/science/article/abs/pii/S0967066118300030), [[8]](https://onlinelibrary.wiley.com/doi/10.1155/2019/6460156).  
- Saturation: fraction of time allocator clips; integrator at limits [[1]](https://docs.px4.io/main/en/flight_stack/controller_diagrams), [[18]](https://github.com/PX4/PX4-Autopilot/blob/master/src/modules/mc_rate_control/mc_rate_control_params.c).  
- Noise/thermal: motor temperature rise and high-frequency actuator activity (PX4 warns high D amplifies noise → hot motors) [[2]](https://docs.px4.io/main/en/config_mc/pid_tuning_guide_multicopter).  
- Energy: control effort / power consumption (explicitly studied in robust PID work) [[9]](https://www.sciencedirect.com/science/article/abs/pii/S001905781930391X).

### 5.3 Prefer frequency-domain or model-informed tuning when the envelope is wide
Manual “feel-based” tuning often yields a hover-optimal tune. To expand robustness:

- **Loop shaping / margin-based design**  
  A 2025 fixed-wing study proposes a systematic loop-shaping workflow targeting gain/phase margins using a high-fidelity 6-DoF model including actuator dynamics, then discretizes and validates in nonlinear simulation and flight tests [[24]](https://www.researchgate.net/publication/396585491_Loop_Shaping-Based_Attitude_Controller_Design_and_Flight_Validation_for_a_Fixed-Wing_UAV). This is a pragmatic midpoint between hand tuning and heavy robust control.

- **Account explicitly for latency from filtering and I/O**  
  PX4 shows latency can change materially with filter cutoffs and hardware paths (e.g., IO chip vs AUX pins) and links latency reductions to achievable P gains [[17]](https://docs.px4.io/main/en/config_mc/filter_tuning).  
  This means “optimal gains” are not separable from filter design: you should co-design filters and gains.

### 5.4 Constrain gains with actuator and noise realities
A good “optimal selection” process enforces constraints:

- **Actuator saturation / slew constraints**:  
  Use integrator limits and anti-windup; consider slew limiting (ArduPilot SMAX) [[13]](https://github.com/ArduPilot/ardupilot/blob/master/libraries/AC_PID/AC_PID.cpp); avoid commanding unrealistic accelerations (setpoint shaping) [[15]](https://ardupilot.org/dev/docs/copter-adding-custom-controller.html).

- **Noise constraints**:  
  D-term is most noise-sensitive; PX4 explicitly warns too-high D causes twitchy/hot motors [[2]](https://docs.px4.io/main/en/config_mc/pid_tuning_guide_multicopter). Use notches/dynamic notch/harmonic notch so you don’t have to over-low-pass (which adds phase lag) [[16]](https://ardupilot.org/copter/docs/common-imu-notch-filtering.html), [[17]](https://docs.px4.io/main/en/config_mc/filter_tuning).

### 5.5 Multi-condition tuning: optimize for a *set* of operating points, not one
A practical envelope-based approach:

1. Choose representative operating points:  
   - multirotor: hover (mid voltage), high-throttle climb, low-voltage hover, with payload, in wind.  
   - fixed-wing: low speed near AIRSPEED_MIN, cruise, high speed near AIRSPEED_MAX, gusty conditions.

2. For each operating point, evaluate tracking, saturation, and noise metrics via logs (PX4 Flight Review explicitly supports tracking plots and FFT-based diagnostics) [[71]](https://docs.px4.io/main/en/log/flight_review). ArduPilot provides Filter Review / PID Review tools to analyze noise and tune effects without re-flying in some cases [[72]](https://firmware.ardupilot.org/Tools/WebTools/), [[73]](https://ardupilot.org/copter/docs/common-webtools.html).

3. If one set of gains fails:
   - first fix linearization (thrust curve, voltage scaling) [[2]](https://docs.px4.io/main/en/config_mc/pid_tuning_guide_multicopter), [[38]](https://ardupilot.org/copter/docs/setting-up-for-tuning.html), [[40]](https://ardupilot.org/copter/docs/motor-thrust-scaling.html);  
   - then implement scheduling (airspeed scaling [[36]](https://ardupilot.org/plane/docs/airspeed-parameters-setup.html), throttle attenuation [[47]](https://betaflight.com/docs/development/PID-tuning), oscillation-triggered gain compression [[44]](https://docs.px4.io/main/en/features_fw/gain_compression));  
   - then consider adaptive methods if needed [[29]](https://reference-global.com/article/10.2478/ama-2024-0004), [[32]](https://safeopt.readthedocs.io/).

---

## 6) Validation and deployment methodology (how to make the improvements stick)

### 6.1 Simulation → HITL/SITL → flight, with regression tooling
- **PX4** supports SITL and HITL with defined MAVLink HIL interfaces and lockstep simulation; it documents how to analyze logs and compare setpoint vs estimate for tracking, plus vibration/FFT diagnostics [[67]](https://docs.px4.io/main/en/simulation/), [[68]](https://docs.px4.io/main/en/simulation/hitl), [[70]](https://docs.px4.io/main/en/log/flight_log_analysis), [[71]](https://docs.px4.io/main/en/log/flight_review).  
- **ArduPilot** supports SITL widely and provides developer-grade regression tooling (AutoTest) for repeatable scenarios [[75]](https://ardupilot.org/dev/docs/the-ardupilot-autotest-framework.html), plus Replay to replay logs through new code/parameter changes [[74]](https://ardupilot.org/dev/docs/testing-with-replay.html).  
- Both ecosystems provide detailed log-analysis workflows; ArduPilot’s WebTools (Filter Review, PID Review) are specifically aimed at filter/tune evaluation from logs [[72]](https://firmware.ardupilot.org/Tools/WebTools/), [[73]](https://ardupilot.org/copter/docs/common-webtools.html).

### 6.2 Standardize flight-test maneuvers for tuning and envelope verification
Common, effective maneuvers (supported by PX4/ArduPilot tuning guidance) include:
- Hover step inputs (fast stick deflections) to evaluate overshoot/oscillation and rate tracking [[2]](https://docs.px4.io/main/en/config_mc/pid_tuning_guide_multicopter).  
- Tilt-and-release and “stabilize within 2 oscillations” checks (PX4 pre-autotune gate) [[3]](https://docs.px4.io/main/en/config/autotune_mc).  
- High-throttle segments to test for throttle-region oscillations (where thrust nonlinearity and vibration peaks may shift) [[2]](https://docs.px4.io/main/en/config_mc/pid_tuning_guide_multicopter), [[17]](https://docs.px4.io/main/en/config_mc/filter_tuning).  
- Aggressive flips/fast angular references when relevant (literature shows performance differences emerge strongly here) [[7]](https://www.researchgate.net/publication/328171772_Disturbance_observer-based_quadrotor_attitude_tracking_control_for_aggressive_maneuvers).  
- Disturbance tests if safe (wind exposure, payload swing); literature uses repeatable gust tests to quantify max deviation [[6]](https://www.sciencedirect.com/science/article/abs/pii/S0967066118300030).

For more formal handling-qualities style evaluation, UAS-specific maneuver sets and scaled bandwidth/disturbance rejection metrics have been proposed based on ADS-33E concepts adapted to UAS [[76]](https://www.sjsu.edu/researchfoundation/docs/VFS_2022_Ivler.PDF).

---

# Practical recommendations (what to do in practice)

## A) If you want the **best performance while keeping PID**
1) **Make thrust/actuator behavior as linear and consistent as possible**  
   - PX4: tune/fit THR_MDL_FAC if high-throttle oscillations appear [[2]](https://docs.px4.io/main/en/config_mc/pid_tuning_guide_multicopter).  
   - ArduPilot: verify MOT_THST_EXPO suitability and voltage setup; nonlinearity here can block good tuning [[38]](https://ardupilot.org/copter/docs/setting-up-for-tuning.html), [[40]](https://ardupilot.org/copter/docs/motor-thrust-scaling.html).  

2) **Fix noise and latency properly (mechanics + notches + LPF cutoffs)**  
   - Use harmonic/dynamic notch to remove motor peaks, then raise LPF cutoffs to reduce delay, then tune P/D [[16]](https://ardupilot.org/copter/docs/common-imu-notch-filtering.html), [[17]](https://docs.px4.io/main/en/config_mc/filter_tuning).  

3) **Use feedforward and setpoint shaping to reduce dependence on high gains**  
   - Enable/adjust rate feedforward (PX4 MC_*_FF) [[18]](https://github.com/PX4/PX4-Autopilot/blob/master/src/modules/mc_rate_control/mc_rate_control_params.c); use input shaping (ArduPilot ATC_INPUT_TC and accel limiting) [[15]](https://ardupilot.org/dev/docs/copter-adding-custom-controller.html), [[14]](https://ardupilot.org/copter/docs/traditional-helicopter-tuning-other-topics.html).  

4) **Ensure anti-windup and integrator management are correct for saturation and transitions**  
   - Confirm integrator limits and conditional integration; manage I across landing/ground and mode changes [[13]](https://github.com/ArduPilot/ardupilot/blob/master/libraries/AC_PID/AC_PID.cpp), [[14]](https://ardupilot.org/copter/docs/traditional-helicopter-tuning-other-topics.html), [[12]](https://github.com/ArduPilot/ardupilot/blob/master/libraries/AC_AttitudeControl/AC_AttitudeControl.h).  

5) **Tune in the correct order and verify bandwidth separation**  
   - Rate loop first, then attitude P [[1]](https://docs.px4.io/main/en/flight_stack/controller_diagrams), [[2]](https://docs.px4.io/main/en/config_mc/pid_tuning_guide_multicopter); watch for slow oscillations indicating cascade mismatch [[3]](https://docs.px4.io/main/en/config/autotune_mc).

## B) If performance still varies a lot across regimes: **add gain scheduling**
- Fixed-wing: rely on/validate airspeed-based scaling and ensure SCALING_SPEED is set correctly before tuning [[36]](https://ardupilot.org/plane/docs/airspeed-parameters-setup.html), [[35]](https://ardupilot.org/plane/docs/new-roll-and-pitch-tuning.html).  
- Multirotor: if high-throttle oscillations persist even with thrust linearization and filtering, use throttle-based attenuation where available (Betaflight TPA) [[47]](https://betaflight.com/docs/development/PID-tuning).  
- Add protective adaptation where available (PX4 gain compression on fixed-wing) [[44]](https://docs.px4.io/main/en/features_fw/gain_compression).

## C) If the environment/missions change too much for scheduling: **consider adaptive tuning**
- Use onboard autotune where mature (PX4, ArduPilot Copter) with correct prerequisites and calm conditions; respect their stated limitations (flexible frames, saturation, delays) [[3]](https://docs.px4.io/main/en/config/autotune_mc), [[56]](https://ardupilot.org/copter/docs/autotune.html).  
- For advanced deployments: safe BO / safe exploration frameworks [[32]](https://safeopt.readthedocs.io/) or structured ID + robust tuning-rule workflows [[28]](https://www.mdpi.com/2072-4292/14/7/1540) are often more defensible than unconstrained online learning.

---

## Key takeaway
To enhance “actual control performance” of PID across diverse UAV flight states, you typically need **a stack of measures**, not “better PID gains” alone:

1) **Normalize the plant** (thrust/voltage/airspeed compensation) [[2]](https://docs.px4.io/main/en/config_mc/pid_tuning_guide_multicopter), [[36]](https://ardupilot.org/plane/docs/airspeed-parameters-setup.html), [[40]](https://ardupilot.org/copter/docs/motor-thrust-scaling.html)  
2) **Make feedback robust to saturation and noise** (anti-windup, filtering, notch strategy, latency control) [[1]](https://docs.px4.io/main/en/flight_stack/controller_diagrams), [[13]](https://github.com/ArduPilot/ardupilot/blob/master/libraries/AC_PID/AC_PID.cpp), [[16]](https://ardupilot.org/copter/docs/common-imu-notch-filtering.html), [[17]](https://docs.px4.io/main/en/config_mc/filter_tuning)  
3) **Reduce required feedback effort** (feedforward + setpoint shaping) [[18]](https://github.com/PX4/PX4-Autopilot/blob/master/src/modules/mc_rate_control/mc_rate_control_params.c), [[15]](https://ardupilot.org/dev/docs/copter-adding-custom-controller.html), [[19]](https://betaflight.com/docs/wiki/tuning/3-5-tuning-notes)  
4) **Schedule or adapt gains** based on the dominant changing variable (airspeed, throttle, mass, oscillation detection) [[36]](https://ardupilot.org/plane/docs/airspeed-parameters-setup.html), [[47]](https://betaflight.com/docs/development/PID-tuning), [[29]](https://reference-global.com/article/10.2478/ama-2024-0004), [[44]](https://docs.px4.io/main/en/features_fw/gain_compression)  
5) **Select gains via multi-condition objectives and constraints**, validated by logs/FFT and repeatable tests, not by hover feel alone [[71]](https://docs.px4.io/main/en/log/flight_review), [[72]](https://firmware.ardupilot.org/Tools/WebTools/), [[76]](https://www.sjsu.edu/researchfoundation/docs/VFS_2022_Ivler.PDF)

If you tell me your UAV type (multirotor / fixed-wing / VTOL), sensors (airspeed? RPM telemetry?), propulsion details, and which flight controller stack you’re targeting (PX4/ArduPilot/Betaflight/INAV), I can outline a concrete tuning + scheduling plan (including which parameters to touch first and what log plots/metrics to use).
