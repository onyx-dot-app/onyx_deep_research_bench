Query ID: 70
============================================================

QUESTION:
Trace the evolution from Java Servlets to the Spring Boot framework. Explain the problems each iteration aimed to solve, and detail the core functionalities of the Spring framework along with essential knowledge required for developers working with it.

============================================================

RESEARCH TASKS (6 total):
  #1: Research the original design goals of Java Servlets (request/response lifecycle, container model, threading, deployment) and the common pain points of building full web apps with plain servlets; include the best practices that emerged (front controller, filters, MVC separation, session management, thread safety). Use web sources and historical references.
  #2: Research the evolution from Servlets to JSP/JSTL and early Java EE web tier: what problems JSP aimed to solve, how taglibs/JSTL worked, and what new issues arose (scriptlets, mixing logic/view, maintainability, scalability) that motivated MVC frameworks. Use web sources and concise timeline.
  #3: Research major pre-Spring Java web frameworks between servlets/JSP and Spring (Struts 1/2, WebWork, JSF, Tapestry, others): what they solved (MVC routing, form handling, validation), and their limitations (config heaviness, testability, coupling, statefulness). Provide key dates and distinguishing characteristics.
  #4: Research the emergence and evolution of the Spring Framework (from early 2002/2004 to Spring Framework 6.x in 2026): motivations as an alternative to heavyweight Java EE (EJB), key concepts (IoC/DI, AOP), major milestones (Spring 2.0, 3.0, 4/5, 6), and how Spring MVC evolved from the servlet model. Prefer primary sources such as Rod Johnson writings, Spring reference docs, and release notes.
  #5: Research Spring Boot (1.x to 3.x+ up to 2026): what problems it aimed to solve on top of Spring (auto-configuration, starter dependencies, embedded servers, packaging, externalized configuration, Actuator/observability), and key breaking changes (Boot 2→3, Java/Jakarta requirements). Include modern practices: Java 17/21, Jakarta namespace, native images (GraalVM), Micrometer/OTel, cloud deployment patterns.
  #6: Research the core functionalities Spring developers must understand today and the essential non-Spring knowledge required: IoC container and bean lifecycle, configuration styles (XML/Java config/annotations), AOP, Spring MVC vs WebFlux, data access (JDBC, JPA, Spring Data), transactions, validation, security, testing, messaging/integration, scheduling, configuration properties/profiles, plus essential HTTP/concurrency, exception handling, logging/metrics, build tools (Maven/Gradle), containerization, and common pitfalls. Use authoritative sources (Spring reference docs) where possible.

============================================================

ANSWER:
## 1) Java Servlets: the original web “engine room” (mid‑/late‑1990s →)

### What Servlets were designed to do
Servlets introduced a **standard, portable server-side Java API** for the web that runs inside a **servlet container** (Tomcat, Jetty, app servers). The container provides networking, request parsing, response formatting, lifecycle management, security boundaries, and concurrency infrastructure, while the developer writes a Java component that receives a request and produces a response [[3]](https://jakarta.ee/specifications/servlet/5.0/jakarta-servlet-spec-5.0).

**Core design points:**
- **Request/response model**: container calls `service(request, response)` for each incoming request; HTTP servlets typically implement `doGet`, `doPost`, etc. via `HttpServlet` [[3]](https://jakarta.ee/specifications/servlet/5.0/jakarta-servlet-spec-5.0).
- **Lifecycle managed by container**:
  - load class → instantiate → `init()` once → call `service()` many times → `destroy()` once on shutdown/undeploy [[3]](https://jakarta.ee/specifications/servlet/5.0/jakarta-servlet-spec-5.0), [[4]](https://docs.oracle.com/javaee/6/tutorial/doc/bnafi.html).
  - initialization is intended for one-time resource setup (e.g., DB connections) and reading config via `ServletConfig`/`ServletContext` [[3]](https://jakarta.ee/specifications/servlet/5.0/jakarta-servlet-spec-5.0).
- **Concurrency model**: container commonly uses **one servlet instance per servlet declaration** and processes concurrent requests by running `service()` concurrently on multiple threads [[3]](https://jakarta.ee/specifications/servlet/5.0/jakarta-servlet-spec-5.0). This made servlets far more efficient than CGI (process-per-request) but pushed thread-safety responsibility onto developers [[3]](https://jakarta.ee/specifications/servlet/5.0/jakarta-servlet-spec-5.0).
- **Portable deployment**: by Servlet 2.2, Java webapps were packaged as **WAR files** with a standardized directory layout and a deployment descriptor `WEB-INF/web.xml` for servlet registration, URL mappings, session timeouts, error pages, security constraints, etc. [[5]](https://www.servlets.com/soapbox/servlet22.html).

### Pain points of building full web apps with “plain servlets”
Servlets are *powerful but low-level*. Building complete applications directly with servlets forced teams to reinvent higher-level web architecture repeatedly.

1) **Presentation pain (HTML in Java)**
- A classic servlet rendered HTML via `PrintWriter.println(...)`, tightly coupling layout to code and making pages tedious to author and maintain.
- This mixing undermined separation of concerns and made collaboration between designers and backend developers difficult (two different workflows touching the same files) [[7]](https://www.infoworld.com/article/2162598/solve-your-servlet-based-presentation-problems.html).

2) **Reinventing common web “infrastructure”**
Using plain servlets often meant hand-building:
- routing conventions, parameter parsing and binding
- validation patterns
- consistent error handling
- authentication/authorization hooks
- view/template reuse and layouts
- multipart upload handling
- logging/auditing and other cross-cutting concerns

3) **Thread safety & shared state hazards**
Because the container can run multiple requests concurrently through one servlet instance, developers had to be careful about:
- mutable instance fields
- shared caches and static state
- session data correctness under concurrent access
Servlet’s deprecated `SingleThreadModel` never truly solved concurrency (sessions/statics still concurrent) and was discouraged/deprecated [[3]](https://jakarta.ee/specifications/servlet/5.0/jakarta-servlet-spec-5.0), [[8]](https://docs.oracle.com/javaee/7/api/javax/servlet/SingleThreadModel.html).

### Best practices that emerged inside the Servlet ecosystem
Even before Spring, the Servlet platform introduced mechanisms and patterns that became the foundation for later frameworks:

- **Filters** (Servlet 2.3): reusable request/response preprocessors/postprocessors for cross-cutting concerns such as authentication, logging, compression, encryption, and transformations; implemented via `Filter` + `FilterChain` [[11]](https://www.servlets.com/soapbox/servlet23.html). This is the conceptual ancestor of many “interceptor” and “middleware” stacks.
- **Listeners / lifecycle events**: `ServletContextListener`, `HttpSessionListener`, request/session/context attribute listeners to centralize startup/shutdown and state tracking logic [[11]](https://www.servlets.com/soapbox/servlet23.html), [[4]](https://docs.oracle.com/javaee/6/tutorial/doc/bnafi.html).
- **Front Controller pattern**: centralize routing/dispatch and standardize request handling. Later frameworks (including Spring MVC) institutionalized this pattern with a single dispatch servlet [[47]](https://docs.spring.io/spring-framework/reference/web/webmvc/mvc-servlet.html).

---

## 2) JSP + JSTL: separating view from code… then rediscovering new problems (1999 →)

### What JSP tried to solve vs servlets
**JSP (JavaServer Pages)** was introduced as a higher-level abstraction over servlets for rendering dynamic content:
- It aimed to **separate presentation from content generation**, letting page authors work in HTML-like templates while still accessing server-side data [[16]](https://www.infoworld.com/article/2164578/understanding-javaserver-pages-model-2-architecture.html).
- Architecturally, JSP is implemented by translating JSP into a servlet under the hood (conceptually “HTML with embedded dynamic elements”) [[1]](https://en.wikipedia.org/wiki/Jakarta_Servlet), [[16]](https://www.infoworld.com/article/2164578/understanding-javaserver-pages-model-2-architecture.html).

### Model 1 vs Model 2: the “MVC pressure” appears
Early JSP guidance described two architectures [[16]](https://www.infoworld.com/article/2164578/understanding-javaserver-pages-model-2-architecture.html):
- **Model 1**: JSP handles request + business logic + rendering. This often devolved into heavy **scriptlets** (Java code embedded in the page), harming maintainability and team separation [[16]](https://www.infoworld.com/article/2164578/understanding-javaserver-pages-model-2-architecture.html).
- **Model 2**: a **servlet controller** handles request processing and forwards to JSP purely for rendering—this is effectively early mainstream Java **MVC** [[16]](https://www.infoworld.com/article/2164578/understanding-javaserver-pages-model-2-architecture.html).

This was a key turning point: teams realized that JSP alone didn’t guarantee separation—architecture and conventions were needed.

### JSTL and tag libraries: reducing scriptlets
To fight “Java in JSP” spaghetti:
- **Custom tag libraries** encapsulated reusable view logic in Java tag handlers, described by TLD files, imported via `<%@ taglib ... %>` directives [[20]](https://docs.oracle.com/cd/E13222_01/wls/docs92/taglib/quickstart.html).
- **JSTL (JSP Standard Tag Library)** standardized common view operations (iteration, conditionals, formatting, etc.) and pushed JSP toward scriptlet-free pages [[22]](https://jcp.org/aboutJava/communityprocess/final/jsr052/JSR52-ChangeLog_1.1_Final.html).
- **Expression Language (EL)** became central: first introduced with JSTL and then moved into JSP 2.0, making it much easier to access model objects without Java scriptlets [[21]](https://objectcomputing.com/resources/publications/sett/september-2003-jsp-20), [[22]](https://jcp.org/aboutJava/communityprocess/final/jsr052/JSR52-ChangeLog_1.1_Final.html).

### New problems introduced or left unresolved
Even with JSP/JSTL:
- **Complex request handling** still required a controller discipline; without it, JSP pages became mini-programs [[16]](https://www.infoworld.com/article/2164578/understanding-javaserver-pages-model-2-architecture.html).
- **Validation**, **type conversion**, **form handling**, and **navigation** still lacked a unified approach across projects.
- Configuration and conventions varied widely; reusable architecture was still not “productized.”

This created demand for *frameworks*.

---

## 3) The “pre‑Spring” web framework era: standardizing MVC, but trading for complexity (2000s)

### Struts 1: institutionalizing Model 2 MVC for servlet/JSP apps
**Struts 1** (project founded 2000; 1.0 production release 2001) aimed to package common MVC plumbing for servlet/JSP applications [[23]](https://struts.apache.org/announce-2002.html):
- **Controller servlet** dispatching to **Action** classes [[23]](https://struts.apache.org/announce-2002.html)
- **Form handling** support (ActionForms), **automatic JavaBean population**, utilities, and strong **i18n** support [[23]](https://struts.apache.org/announce-2002.html)
- **JSP tag libraries** for form-centric UI development [[23]](https://struts.apache.org/announce-2002.html)
- Validator framework for server-side rules and optional generated JS validation [[26]](https://svn.apache.org/repos/asf/struts/struts1/tags/STRUTS_1_1_B1/contrib/validator/docs/overview.html)

**What it solved**
- Standard MVC routing/dispatch
- Repeatable form processing patterns
- Shared validation and message handling

**Limitations that became painful at scale**
- **Tight coupling to Servlet API** (`HttpServletRequest/Response` passed into actions) hurt unit testability; mocking and specialized test harnesses were needed [[27]](https://struts.staged.apache.org/migration/).
- **Singleton Actions** required careful thread safety, increasing developer burden [[27]](https://struts.staged.apache.org/migration/).
- **Inheritance-heavy design** (abstract base classes) and ActionForm duplication increased ceremony and rigidity [[27]](https://struts.staged.apache.org/migration/).
- Configuration could become large and hard to maintain (multiple XML files; complex flows).

### Struts 2 / WebWork: addressing testability and extensibility issues
Struts 2 (born from WebWork 2) shifted toward:
- **POJO Actions**, per-request instantiation (removing singleton/thread-safety constraints) [[27]](https://struts.staged.apache.org/migration/)
- **Interceptor stacks** rather than a monolithic request processor [[25]](https://struts.apache.org/announce-2006.html), [[27]](https://struts.staged.apache.org/migration/)
- **Reduced HTTP coupling** and improved test story [[25]](https://struts.apache.org/announce-2006.html), [[27]](https://struts.staged.apache.org/migration/)
- Easier integration with IoC (notably Spring) [[25]](https://struts.apache.org/announce-2006.html)

### JSF: component-based server-side UI standardization
**JSF** standardized a server-side **component tree** model with a multi-phase lifecycle (restore view, apply values, validate, update model, invoke application, render) [[32]](https://www.andygibson.net/blog/article/exonerating-the-jsf-lifecycle/).
- It solved UI component reuse and event-driven form handling (especially for enterprise UI-heavy apps).
- Trade-offs included lifecycle complexity and a stateful component model that many teams found hard to align with REST-style thinking (and later SPA/client-heavy architectures).

### Other frameworks (Tapestry, Wicket, Click, Stripes)
These explored component-centric or convention-heavy approaches:
- Component frameworks emphasized reuse and encapsulation, sometimes with strong server-side state management.
- “Lighter” MVC frameworks (e.g., Stripes) aimed to reduce XML and inheritance through annotations and conventions [[42]](https://en.wikipedia.org/wiki/Stripes_(framework)).

### Common theme of the era
Frameworks improved productivity and consistency, but many still suffered from:
- **Configuration heaviness**
- **Intrusive framework coupling**
- **Hard-to-test designs**
- **Inconsistent dependency/version management**
- **Container-centric deployment friction**

This set the stage for Spring’s broader intervention—*not only* in web MVC, but across the whole application architecture.

---

## 4) Spring Framework: from “winter of J2EE” to a unified application model (2002/2004 → 6.x)

### Why Spring happened (the problems it aimed to solve)
Rod Johnson’s account frames Spring as “a fresh start after the ‘winter’ of traditional J2EE” [[44]](https://spring.io/blog/2006/11/09/spring-framework-the-origins-of-a-project-and-a-name). In practice, Spring addressed several systemic pain points prevalent in early‑2000s enterprise Java:

1) **Intrusive programming models**
Traditional enterprise stacks often forced business logic into container-specific base classes/interfaces and patterns (service locators, heavyweight components). Spring’s thesis: keep application code as **POJOs**, and provide infrastructure *around* them [[45]](https://spring.io/blog/2004/03/24/spring-framework-1-0-final-released), [[49]](https://spring.io/blog/2006/10/03/spring-2-0-final-released).

2) **Poor testability**
If your code depends directly on containers (EJB/web containers) and static lookups, unit testing becomes difficult. Spring pushed **Dependency Injection** and componentization so object graphs can be constructed in tests.

3) **Scattered cross-cutting concerns**
Transactions, security, auditing, and other cross-cutting logic tended to leak into business code. Spring brought these concerns into configuration and aspects/interceptors.

4) **Fragmentation**
Teams had “a web framework,” “a data framework,” “a transactions story,” “a scheduler,” each with different conventions. Spring aimed for a cohesive stack with consistent abstractions.

### Key milestones (high-signal evolution)
- **Spring “concepts/code” emerged late 2002; project public June 2003** [[44]](https://spring.io/blog/2006/11/09/spring-framework-the-origins-of-a-project-and-a-name).
- **Spring 1.0 (Mar 2004)**: lightweight container (DI), AOP interception, transaction management, JDBC/Hibernate templates, web MVC, integration utilities; emphasized declarative transactions for POJOs even on plain Tomcat [[45]](https://spring.io/blog/2004/03/24/spring-framework-1-0-final-released).
- **Spring 2.0 (Oct 2006) & 2.5 (Nov 2007)**: XML namespaces (“configuration dialects”), AspectJ pointcut language integration, richer annotation-driven config, component scanning, and the move toward annotation-based MVC controllers in 2.5 [[48]](https://docs.spring.io/spring-framework/docs/2.5.x/reference/new-in-2.html), [[49]](https://spring.io/blog/2006/10/03/spring-2-0-final-released).
- **Spring 3.0 (Dec 2009)**: SpEL, stronger JavaConfig model (`@Configuration`), JSR-330 `@Inject`, JSR-303 Bean Validation integration, major REST support in Spring MVC and `RestTemplate` [[50]](https://spring.io/blog/2009/12/16/spring-framework-3-0-goes-ga).
- **Spring 4.0 (Dec 2013)**: first-class Java 8 support, continued refinement of annotation-based programming, more REST/WebSocket/messaging support [[51]](https://spring.io/blog/2013/12/12/announcing-spring-framework-4-0-ga-release), [[52]](https://docs.spring.io/spring-framework/docs/4.0.0.RELEASE/spring-framework-reference/html/new-in-4.0.html).
- **Spring 5.0**: Java 8 baseline; introduction of **Spring WebFlux** reactive web stack as an alternative to Spring MVC while retaining MVC and adding reactive interoperability features [[53]](https://github.com/spring-projects/spring-framework/wiki/Spring-Framework-5.0-Release-Notes).
- **Spring 6.0+**: Java 17+ baseline and **Jakarta EE 9+** transition (`javax.*` → `jakarta.*`), AOT/native-image foundations, modernization (and removal of older remoting/EJB convenience integration) [[54]](https://github.com/spring-projects/spring-framework/wiki/Spring-Framework-6.0-Release-Notes), [[55]](https://spring.io/blog/2021/09/02/a-java-17-and-jakarta-ee-9-baseline-for-spring-framework-6).

### Spring MVC’s place in this evolution (Servlets → “industrialized Front Controller”)
Spring MVC is explicitly built around the **Front Controller** pattern: `DispatcherServlet` as a central servlet dispatching to controllers and coordinating mappings, model building, view resolution, and exception resolution [[47]](https://docs.spring.io/spring-framework/reference/web/webmvc/mvc-servlet.html).

Early Spring MVC already described a well-defined dispatch pipeline:
- bind request-scoped context, locale/theme resolvers
- optional multipart request wrapping
- choose handler via handler mappings; run pre/post interceptors
- resolve exceptions via `HandlerExceptionResolver`
- render via view resolver if a `ModelAndView` is returned [[46]](https://docs.spring.io/spring-framework/docs/1.2.2/reference/mvc.html)

Over time, the controller model shifted from interface-based `Controller#handleRequest(...)` returning `ModelAndView` [[46]](https://docs.spring.io/spring-framework/docs/1.2.2/reference/mvc.html) to the modern annotation-driven model (e.g., `@RequestMapping` introduced in Spring 2.5-era changes [[48]](https://docs.spring.io/spring-framework/docs/2.5.x/reference/new-in-2.html), expanded REST features by Spring 3.0 [[50]](https://spring.io/blog/2009/12/16/spring-framework-3-0-goes-ga), and further conveniences like `@RestController` by Spring 4 [[52]](https://docs.spring.io/spring-framework/docs/4.0.0.RELEASE/spring-framework-reference/html/new-in-4.0.html)).

---

## 5) Spring Boot: making Spring *operationally effortless* (Boot 1 → 3.x+)

Spring Framework solved architectural problems (DI, transactions, consistent abstractions), but teams still faced a major gap: **getting applications running consistently and production-ready quickly**.

### What Boot was created to solve
Spring Boot’s own goals are explicit:
- radically faster “getting started”
- “opinionated” defaults that are easy to override
- production-ready non-functional features (embedded servers, security, metrics, health checks, externalized config)
- no code generation (except native-image-related processing), no requirement for XML [[59]](https://docs.spring.io/spring-boot/docs/3.2.5/reference/htmlsingle/)

Concretely, Boot solved:

#### 1) Dependency/version management pain
Without Boot, teams frequently fought “jar hell” and dependency matrix mismatches.

Boot introduced **Starters**: curated dependency descriptors to get coherent feature sets quickly (e.g., web, data-jpa, security, actuator) [[60]](https://docs.spring.io/spring-boot/docs/1.0.x-SNAPSHOT/reference/htmlsingle/). This standardized and stabilized transitive dependencies across projects.

#### 2) Configuration overload in “plain Spring”
Boot introduced **Auto-configuration**: the runtime configures common beans based on classpath dependencies and existing user-defined beans (e.g., if HSQLDB is present and no datasource is configured, auto-configure an in-memory DB; if you define your own `DataSource`, auto-config backs off) [[60]](https://docs.spring.io/spring-boot/docs/1.0.x-SNAPSHOT/reference/htmlsingle/).

#### 3) “App server as a prerequisite” friction
Boot made **embedded servers** mainstream (Tomcat/Jetty/Undertow; Netty for reactive), enabling:
- `java -jar ...` deployment
- consistent local dev experience
- simpler containerization/cloud deployment [[60]](https://docs.spring.io/spring-boot/docs/1.0.x-SNAPSHOT/reference/htmlsingle/), [[59]](https://docs.spring.io/spring-boot/docs/3.2.5/reference/htmlsingle/)

#### 4) Externalized configuration for real environments
Boot formalized property sourcing and override behavior across:
- properties/YAML
- environment variables
- command line args
- packaged vs external config files
with a strict precedence order for predictable overrides [[61]](https://docs.spring.io/spring-boot/reference/features/external-config.html).

It also promoted `@ConfigurationProperties` for structured config binding, and profile-based configuration patterns for environment separation [[75]](https://docs.spring.io/spring-boot/reference/features/profiles.html).

#### 5) Production readiness as a default (Actuator + Observability)
Boot made “day 2” concerns first-class:
- health checks, metrics, monitoring endpoints via Actuator [[60]](https://docs.spring.io/spring-boot/docs/1.0.x-SNAPSHOT/reference/htmlsingle/), [[59]](https://docs.spring.io/spring-boot/docs/3.2.5/reference/htmlsingle/)
- modern observability via Micrometer:
  - Boot 3: Observation API integration, auto-configured `ObservationRegistry`, metrics/tracing bridges, OTLP meter registry when present [[65]](https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-3.0-Release-Notes), [[68]](https://spring.io/blog/2022/10/12/observability-with-spring-boot-3)
  - tracing support via Micrometer Tracing and exporters; default sampling controls; log correlation in logs via trace/span IDs [[67]](https://docs.spring.io/spring-boot/reference/actuator/tracing.html)

### Boot’s major ecosystem transitions: 2.0 and 3.0
#### Spring Boot 2.0
Boot 2.0 aligned with Spring Framework 5 and introduced major improvements including reactive support (WebFlux), Micrometer-based metrics, and a new actuator architecture [[62]](https://spring.io/blog/2018/03/01/spring-boot-2-0-goes-ga). It set a **Java 8 baseline** and required Spring Framework 5 [[63]](https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.0-Migration-Guide).

#### Spring Boot 3.0+
Boot 3 is the “modern Java + Jakarta” line:
- **Java 17+ required** and **Spring Framework 6.0 required** [[64]](https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-3.0-Migration-Guide)
- **Jakarta EE migration**: Boot 3 uses Jakarta EE 10-level specs (e.g., Servlet 6.0, JPA 3.1), requiring dependency and import updates (`javax.*` → `jakarta.*`) [[64]](https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-3.0-Migration-Guide), [[65]](https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-3.0-Release-Notes)
- Numerous breaking cleanup changes (e.g., older auto-config registration mechanism changes) [[64]](https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-3.0-Migration-Guide)

Boot 3.2.x documents compatibility up to recent JDKs while keeping Java 17 minimum, and supports modern deployment options including native images and efficient container images [[59]](https://docs.spring.io/spring-boot/docs/3.2.5/reference/htmlsingle/).

### 2026 reality: why Boot fits “cloud-era Java”
Boot’s evolution aligns with modern deployment and ops expectations:
- **Immutable artifacts** (fat jars, OCI images) + **externalized config** [[60]](https://docs.spring.io/spring-boot/docs/1.0.x-SNAPSHOT/reference/htmlsingle/), [[61]](https://docs.spring.io/spring-boot/reference/features/external-config.html), [[59]](https://docs.spring.io/spring-boot/docs/3.2.5/reference/htmlsingle/)
- **Built-in telemetry** patterns (metrics, tracing, health endpoints) [[65]](https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-3.0-Release-Notes), [[67]](https://docs.spring.io/spring-boot/reference/actuator/tracing.html)
- **Jakarta alignment** across the Java ecosystem [[64]](https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-3.0-Migration-Guide), [[54]](https://github.com/spring-projects/spring-framework/wiki/Spring-Framework-6.0-Release-Notes)
- **Native image** and AOT processing becoming viable for certain workloads (startup/memory improvements) [[59]](https://docs.spring.io/spring-boot/docs/3.2.5/reference/htmlsingle/), [[65]](https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-3.0-Release-Notes), [[54]](https://github.com/spring-projects/spring-framework/wiki/Spring-Framework-6.0-Release-Notes)

---

## 6) Core functionalities of Spring (what the framework *is*, independent of Boot)

Below is a practical map of Spring’s core capabilities a developer should understand.

### A) IoC container / Dependency Injection (the heart of Spring)
Spring’s core is its IoC container (`BeanFactory`, `ApplicationContext`) [[71]](https://docs.spring.io/spring-framework/reference/core/beans/introduction.html).

**You must know:**
- **Dependency Injection styles**: constructor vs setter injection; wiring by type/name/qualifier.
- **Bean definition & scopes**:
  - `singleton` (default), `prototype`, and web scopes like `request` and `session` in web contexts [[72]](https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html)
  - pitfalls such as injecting a prototype into a singleton (you only get one instance unless you use method injection/proxy patterns) [[72]](https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html)
- **Bean lifecycle callbacks**:
  - `@PostConstruct` / `@PreDestroy` and/or Spring callbacks (`InitializingBean`, `DisposableBean`), and custom init/destroy methods [[73]](https://docs.spring.io/spring-framework/reference/core/beans/factory-nature.html)
  - ordering rules: `@PostConstruct` → `afterPropertiesSet()` → custom init method; destruction is `@PreDestroy` → `destroy()` → custom destroy [[73]](https://docs.spring.io/spring-framework/reference/core/beans/factory-nature.html)
  - initialization deadlock risks: `@PostConstruct` runs under singleton creation locks; use `SmartInitializingSingleton` or context refresh events for post-start work [[73]](https://docs.spring.io/spring-framework/reference/core/beans/factory-nature.html)

### B) AOP (cross-cutting concerns)
Spring AOP is **proxy-based** [[76]](https://docs.spring.io/spring-framework/reference/core/aop/introduction-proxies.html), [[77]](https://docs.spring.io/spring-framework/reference/core/aop/proxying.html). It powers many “magic” features: transactions, security method interception, async, caching, method validation, etc.

**You must know:**
- JDK dynamic proxies vs CGLIB class proxies and constraints (final classes/methods, private methods, module system implications) [[77]](https://docs.spring.io/spring-framework/reference/core/aop/proxying.html)
- **Self-invocation pitfall**: internal calls (`this.someMethod()`) bypass the proxy, so advice (e.g., `@Transactional`) won’t run unless the call goes through the proxy [[77]](https://docs.spring.io/spring-framework/reference/core/aop/proxying.html)
- When AspectJ weaving differs (no self-invocation issue) [[77]](https://docs.spring.io/spring-framework/reference/core/aop/proxying.html)

### C) Spring MVC (Servlet stack) and Spring WebFlux (Reactive stack)
**Spring MVC**
- Servlet-based, `DispatcherServlet` front controller, controller mappings, handler adapters, view resolution, exception resolvers [[47]](https://docs.spring.io/spring-framework/reference/web/webmvc/mvc-servlet.html)
- Exception handling with `@ExceptionHandler` / `@ControllerAdvice` and how resolution works across exception depth and cause chains [[82]](https://docs.spring.io/spring-framework/reference/web/webmvc/mvc-controller/ann-exceptionhandler.html)

**Spring WebFlux**
- Non-blocking reactive stack based on Reactive Streams and Reactor (`Mono`, `Flux`) [[79]](https://docs.spring.io/spring-framework/reference/web/webflux/new-framework.html)
- Different concurrency model: small event-loop thread pools; blocking calls are problematic unless isolated onto separate schedulers [[79]](https://docs.spring.io/spring-framework/reference/web/webflux/new-framework.html)
- Choosing MVC vs WebFlux is often determined by whether your persistence and downstream calls are blocking (JPA/JDBC → MVC is usually the right default) [[79]](https://docs.spring.io/spring-framework/reference/web/webflux/new-framework.html)

### D) Data access + transactions
Spring’s long-standing value proposition: consistent data access and **declarative transactions for POJOs** [[45]](https://spring.io/blog/2004/03/24/spring-framework-1-0-final-released).

Modern developer essentials:
- Spring transaction boundaries (`@Transactional`) and propagation semantics (conceptually)
- Spring Data repository transaction defaults (e.g., CRUD methods typically transactional with read-only optimizations for reads) [[80]](https://docs.spring.io/spring-data/jpa/reference/jpa/transactions.html)
- The meaning of `readOnly=true` (hint/optimization; not an absolute guard) and provider-specific benefits such as Hibernate flush mode changes [[80]](https://docs.spring.io/spring-data/jpa/reference/jpa/transactions.html)

### E) Validation (Bean Validation + method validation)
- Bean Validation integration via `LocalValidatorFactoryBean`, which can act as both Spring and Jakarta validator adapters [[78]](https://docs.spring.io/spring-framework/reference/core/validation/beanvalidation.html)
- Custom constraint validators can be dependency-injected via Spring’s constraint validator factory integration [[78]](https://docs.spring.io/spring-framework/reference/core/validation/beanvalidation.html)
- Method validation via `MethodValidationPostProcessor` + `@Validated`, noting that method validation uses AOP proxies and inherits proxy limitations [[78]](https://docs.spring.io/spring-framework/reference/core/validation/beanvalidation.html), [[77]](https://docs.spring.io/spring-framework/reference/core/aop/proxying.html)

### F) Security (Spring Security)
Spring Security is structurally built on the Servlet filter chain:
- Container filter chain → `DelegatingFilterProxy` → Spring Security `FilterChainProxy` → one matching `SecurityFilterChain` with ordered security filters (authentication before authorization) [[83]](https://docs.spring.io/spring-security/reference/servlet/architecture.html)
Knowing *how requests traverse filters* is essential to debugging authentication and authorization issues [[83]](https://docs.spring.io/spring-security/reference/servlet/architecture.html).

### G) Scheduling and async execution
- `@EnableScheduling`, `@Scheduled` rules (void methods, no args; DI for dependencies) and overlap pitfalls [[74]](https://docs.spring.io/spring-framework/reference/integration/scheduling.html)
- Async execution proxy limitations similar to AOP (local calls not intercepted) [[74]](https://docs.spring.io/spring-framework/reference/integration/scheduling.html)
- Newer scheduling support aligning with virtual threads and lifecycle management (e.g., `SimpleAsyncTaskScheduler` and improvements in 6.1+) [[74]](https://docs.spring.io/spring-framework/reference/integration/scheduling.html)

### H) Testing support
- `WebTestClient` for end-to-end tests, and also for testing MVC/WebFlux without running a server (mocked request/response) [[85]](https://docs.spring.io/spring-framework/reference/testing/webtestclient.html)
- Spring Security testing utilities exist as a dedicated dependency for security test support [[84]](https://docs.spring.io/spring-security/reference/servlet/test/index.html)

---

## 7) Essential knowledge for developers working with Spring / Spring Boot (the “non-negotiables”)

Spring dramatically increases productivity—but only if you understand the underlying platform realities it builds on.

### A) HTTP + servlet fundamentals (even if you “only do Spring Boot”)
You need to understand:
- request methods, headers, cookies, sessions, idempotency
- multipart uploads, redirects, caching headers
- servlet container threading model and why “singleton beans + mutable state” can be dangerous (same conceptual risk as servlet instance variables) [[3]](https://jakarta.ee/specifications/servlet/5.0/jakarta-servlet-spec-5.0)

### B) Concurrency and execution models
- In MVC/servlet apps: thread-per-request is common; avoid blocking bottlenecks, manage pool saturation.
- In WebFlux: event-loop model; don’t block the event loop; understand backpressure at least conceptually [[79]](https://docs.spring.io/spring-framework/reference/web/webflux/new-framework.html).

### C) DI design skills (beyond annotations)
- designing components with clear responsibilities
- constructor injection and immutability patterns
- avoiding “god services” and circular dependencies
- understanding scopes, proxies for scoped beans, and lifecycle impacts [[72]](https://docs.spring.io/spring-framework/docs/3.2.x/spring-framework-reference/html/beans.html)

### D) Proxy-based “magic” literacy (AOP consequences)
To be effective, you must be able to answer:
- Is this feature implemented via proxy?
- Will my call go through the proxy?
- What happens on self-invocation?
These questions are central to transactions, async, method validation, and security method interception [[77]](https://docs.spring.io/spring-framework/reference/core/aop/proxying.html), [[78]](https://docs.spring.io/spring-framework/reference/core/validation/beanvalidation.html), [[74]](https://docs.spring.io/spring-framework/reference/integration/scheduling.html).

### E) Configuration mastery (Boot especially)
- property precedence and override rules [[61]](https://docs.spring.io/spring-boot/reference/features/external-config.html)
- profiles and rules around `spring.profiles.active/default/include` [[75]](https://docs.spring.io/spring-boot/reference/features/profiles.html)
- config binding (`@ConfigurationProperties`) vs ad-hoc `@Value`
- safe handling of secrets and environment-specific settings

### F) Observability and production readiness
Modern Spring Boot expects you to treat telemetry as part of the app:
- metrics, health checks, readiness/liveness (Actuator) [[59]](https://docs.spring.io/spring-boot/docs/3.2.5/reference/htmlsingle/)
- tracing and sampling, propagation, log correlation IDs [[67]](https://docs.spring.io/spring-boot/reference/actuator/tracing.html)
- how Micrometer observation/tracing ties metrics ↔ traces ↔ logs together [[68]](https://spring.io/blog/2022/10/12/observability-with-spring-boot-3), [[65]](https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-3.0-Release-Notes)

### G) Build tooling and packaging
- Maven/Gradle basics, dependency management, reproducible builds
- Boot packaging model (fat jars), container images/buildpacks, external config injection [[59]](https://docs.spring.io/spring-boot/docs/3.2.5/reference/htmlsingle/), [[60]](https://docs.spring.io/spring-boot/docs/1.0.x-SNAPSHOT/reference/htmlsingle/)
- migration awareness across Boot 2 → 3 (Java 17, Jakarta namespaces) [[64]](https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-3.0-Migration-Guide)

### H) Common Spring anti-patterns to avoid
- Treating Spring as a “service locator” rather than DI (injecting `ApplicationContext` everywhere).
- Mutable singleton beans holding request/user state.
- Putting blocking JPA/JDBC calls into WebFlux pipelines without isolation [[79]](https://docs.spring.io/spring-framework/reference/web/webflux/new-framework.html).
- Assuming `@Transactional` works on internal method calls (self-invocation) [[77]](https://docs.spring.io/spring-framework/reference/core/aop/proxying.html).
- Overusing `@Autowired` field injection (harms testability and clarity) in favor of constructor injection.
- Creating overly complex conditional configuration and bean overriding battles (especially in large Boot apps).

---

## 8) Putting the evolution together (Servlets → Spring Boot as a sequence of problems solved)

### Iteration-by-iteration summary
1) **Servlets**
- Solved: portable Java web runtime; efficient threading vs CGI; standardized lifecycle and packaging [[3]](https://jakarta.ee/specifications/servlet/5.0/jakarta-servlet-spec-5.0), [[5]](https://www.servlets.com/soapbox/servlet22.html)
- Created pain: HTML generation in Java; no standard MVC; manual infrastructure; concurrency hazards [[7]](https://www.infoworld.com/article/2162598/solve-your-servlet-based-presentation-problems.html), [[3]](https://jakarta.ee/specifications/servlet/5.0/jakarta-servlet-spec-5.0)

2) **JSP / JSTL / EL**
- Solved: template-friendly rendering; reduced need to write HTML in Java; taglibs/EL reduced scriptlets [[16]](https://www.infoworld.com/article/2164578/understanding-javaserver-pages-model-2-architecture.html), [[22]](https://jcp.org/aboutJava/communityprocess/final/jsr052/JSR52-ChangeLog_1.1_Final.html), [[21]](https://objectcomputing.com/resources/publications/sett/september-2003-jsp-20)
- Created/left pain: scriptlet abuse; weak architectural enforcement; controller/validation/binding still ad hoc without frameworks [[16]](https://www.infoworld.com/article/2164578/understanding-javaserver-pages-model-2-architecture.html)

3) **MVC frameworks (Struts, JSF, etc.)**
- Solved: standardized routing/controllers, form processing, taglibs and validation, component models [[23]](https://struts.apache.org/announce-2002.html), [[26]](https://svn.apache.org/repos/asf/struts/struts1/tags/STRUTS_1_1_B1/contrib/validator/docs/overview.html), [[32]](https://www.andygibson.net/blog/article/exonerating-the-jsf-lifecycle/)
- Created pain: configuration heaviness; intrusive base classes; servlet coupling; poor unit test ergonomics; lifecycle complexity/statefulness in some stacks [[27]](https://struts.staged.apache.org/migration/), [[32]](https://www.andygibson.net/blog/article/exonerating-the-jsf-lifecycle/)

4) **Spring Framework**
- Solved: POJO-first architecture; DI/IoC; consistent transaction management; AOP-based cross-cutting; a cohesive ecosystem including (but not limited to) MVC [[45]](https://spring.io/blog/2004/03/24/spring-framework-1-0-final-released), [[49]](https://spring.io/blog/2006/10/03/spring-2-0-final-released)
- Evolved: annotation configuration, REST support, reactive stack (WebFlux), and ultimately Jakarta + modern Java baselines [[48]](https://docs.spring.io/spring-framework/docs/2.5.x/reference/new-in-2.html), [[50]](https://spring.io/blog/2009/12/16/spring-framework-3-0-goes-ga), [[53]](https://github.com/spring-projects/spring-framework/wiki/Spring-Framework-5.0-Release-Notes), [[54]](https://github.com/spring-projects/spring-framework/wiki/Spring-Framework-6.0-Release-Notes)

5) **Spring Boot**
- Solved: operational friction—dependency curation (starters), auto-configuration, embedded servers, external config discipline, production-ready endpoints and observability [[60]](https://docs.spring.io/spring-boot/docs/1.0.x-SNAPSHOT/reference/htmlsingle/), [[61]](https://docs.spring.io/spring-boot/reference/features/external-config.html), [[59]](https://docs.spring.io/spring-boot/docs/3.2.5/reference/htmlsingle/), [[65]](https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-3.0-Release-Notes)
- Modernized: Boot 3 aligned Spring with Java 17+ and Jakarta EE namespaces; added first-class observability and native-image viability for selected use cases [[64]](https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-3.0-Migration-Guide), [[65]](https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-3.0-Release-Notes), [[59]](https://docs.spring.io/spring-boot/docs/3.2.5/reference/htmlsingle/)

---

If you want, I can also provide:
- a “minimum competence checklist” for a developer joining a Spring Boot team (what to learn in week 1 vs month 1),
- a side-by-side mapping of **Servlet Filters / Struts Interceptors / Spring HandlerInterceptors / Spring Security filters** and what concerns belong where,
- or a concrete walkthrough showing how a request flows from the network socket through Tomcat → filters → Spring Security → DispatcherServlet → controller → service → repository → transaction manager → exception handler → JSON serialization.
